# Programmation en C++

Zhor Sebbani

## Lecture 1

### Difference entre C++ et java

1. Compilation: .obj vs .class
2. Conception:
   - C++ permet la Programmation Oriente Objet et procedurale
   - Java est purement oriente
3. Variable constante: const vs final
4. Methodes constantes:
   - C++: Le mot-clé const est placé après la déclaration de la méthode. Seules les méthodes constantes peuvent agir sur un objet constant
   - Java:
5. Conversion de type - C++: Toutes les conversions de type par affectation sont acceptées quitte à dégrader fortement l'information - Java: Seules les conversions qui relèvent de promotion numérique sont autorisées par affectation (les autres doivent être demandées explicitement)
6. Definition de classe:
   - C++: declarer dans un fichier .h distinct du fichier d'implimentation (.cpp)
7. Pointer: java n'a pas de pointeur
8. Instanciation d'dune classe:
   - Java: always use new and get reference to object not address
   - C++: 1. Declaration et 2. new
9. Instanciation - Constructeur par default
   - Java: parenthese obligatoire
   - C++ : parenthese non obligatoire

```cpp
A a;
A * a = new A;
A * a = new A();
```

10. Gestion de memoire
11. Passage d'arguments:
12. Initialisation par defaut des champs d'un objet
    - Java: oui e.g 0, false, NULL
    - C++: non
13. Affectation d'objet
14. Valeurs d'argument par defaut: n'existe pas en java
15. Allocation de tableau
    - Java: tjrs dynamique
    - C++ : static ou dynamic

```cpp
int t[10];
int * t = new int [10];
```

16. Taile d'une tableu
    - Java: access a la propriete .length
    - C++ n'a pas
17. Tableaux en memoire: - C++: En C++ les tableaux à plusieurs indices déclarés de manière statique sont contigus en mémoire Ex : int t [10][25] crée 250 cases contigües - Java: En Java les tableaux à plusieurs indices fractionnent la mémoire : int t [][] = new int [10][25] non contigus
18. Heritage: derivation
19. Heritage multiple: c++ oui, non en java
20. Constructeur d'une classe fille
    - Java: super
    - C++ `B::B( int arg1, double arg2):A(arg1)`
21. Derivations successive: C++ oui, java oui (super designe le constructeur de la classes directment successive)
22. Membres proteges:
23. Redefinition de methode:
24. Polymophisme:
25. Classes abstraites
26. Arguments de la ligne de commandes
27. Gestions des flux:
    - C++: graces aux operateurs << >>
    - Java: graces a des classes specialise

### Quelques fonctionnalités qui n'existent pas en C++

1. Super classe - Objet: Les objets en C++ n'herite pas d'une classes commune.
2. Classes et methodes finales

- Une méthode final ne peut pas être redéfinie dans une classe fille
- Une classe final ne peut plus être dérivée

3. Interface: pas d'interface en C++

- Programmation en C++: Edition -> Compilation -> Executtion

### Types elementaires

- int, long int, short int, unsigned int
- Float, double, long double
- char
- booll
- size_t

## Variables

```c
int p = 10;
int p(10);
const int p = 10;
```

```cpp
#include <string>
string t;
string t = "something";
t.size() // get size of string
t[i]; //get char at index i
s + t; //Concatenate two strings

string ch(10, '*'); //creer un string avec 10 *;
```

- String is initialized to empty string by default
- string variable lives in the stack but its data may leave on the heap depending on the size.
- You can return a local string. The compiler will copy it and pass it by value

### Tableaux

- Peut inclure la taile ou pas

```cpp
int tab[2][2] = {1,2,3,4}; //pas besoin de separer les elements, ils sont dans une memoire contigue et distribuer en respect avec la taille
```

- Variable automatique: constante definit dans un bloc ou une fonction
- Tableau statique: toutes les valeur d'initialisation sont des expressions constantes
- Tableau automatique: les valeurs d'initialisation ne sont pas constantes

```cpp
#include <vector>

vector<type> name(n_elements, initialisation_v);
vecotr<int> t(100, 5);
vector<vector<int> > t(10, vector<int>(20)); // Dont forget space > > or it will considered as a stream(un flux)
```

- Post-incrementation, increment a la prochaine instruction.

### Division

- Arrondi au type le plus large

## Fontions

```cpp
void swap (int &a, int& b);  // wil make the compile take the reference of given variables. Not a pointer

int main(){
    int a = 10;
    int b = 20;
    cout << "Before: a = " << a << " b = " << b <<endl;

    swap(a, b);           // pass variables as is. The compiler will only send the references to vars

    cout << "After: a = " << a << " b = " << b <<endl;
    return 0;
}

/// Can work on variables as if normal integers
void swap (int &a, int& b){
    int c;
    c = a;
    a = b;
    b = c;
}
```

## Custom namespaces

```cpp
namespace mine{
    int N = 10;
    void greet(){
        std::cout << "hello" <<endl;
    }
}
```

### Portée, visibilité, durée de vie des variables

##### Portée d’un identificateur

• La portée d’un identificateur correspond aux parties du programme où cet identificateur peut être utilisé sans provoquer d’erreur à la compilation.
• La portée d’une variable globale ou d’une fonction globale est égale au programme.
• La portée d’une variable locale va de sa définition jusqu’à la fin de la première instruction composée ({...}) qui contient sa définition.

##### Visibilité

– La visibilité d’une variable dit quand elle est accessible.
– La visibilité est inclue dans la portée...

##### Durée de vie

– La durée de vie d’une variable correspond à la période depuis sa création à sa destruction.

### Variable locale Static

- Il est possible d’attribuer un emplacement permanent à une variable locale et de conserver ainsi sa valeur d’un appel au suivant. Il suffit de la déclarer static. Sa durée de vie est celle du programme.

```cpp
#include <iostream>
using namespace std;
int main(){
    void fct();
    int n;
    for (n = 1; n <= 5; n++)
        fct();
}
void fct() {
    static int i;
    i++;
    cout << "appel numero : " << i << "\n";
}
```

```bash
/*SORTIE*/
appel numero : 1
appel numero : 2
appel numero : 3
appel numero : 4
appel numero : 5
```

### Valeurs par defaut des parametres

```cpp
int max(int a, int b =0){
    if (a>b) return a ;
    else return b ;
}
```

### Surdéfinition de fonctions

– C++ permet la surdéfinition de fonctions (fonctions ayant le même nom mais des paramètres différents). Le choix de la bonne fonction est basé sur le type des arguments.

```cpp
void process (int);
void process (double);

void test (int&);
void test (const int&);

int n = 10;
float x = 10.0;

test (n); // prototype I
test (x); //prototype II. Parce c q it does much test(int) therefore the convetion is to use it as a const
```

### Pointeurs

- Un pointer est une variable qui peut contenir l'addresse d'une autre choses c.a.d variables, fonctions, ...
- Le nom d'un tableau est un pointeur constant. Lorsqu'il est utilisé sans indice. Il represente le premier element dans le tableau

```cpp
int tab[10];

tab = &tab[0];
tab + i = &tab[i]
*(tab +1) = tab[1];
```

- L-values (Locator values) are expressions that refer to a memory location 12. They represent objects that have an identifiable location in memory and can be modified
- R-values (Right values) are expressions that refer to a memory location but cannot be modified directly 12. They represent temporary objects or constants.

```cpp
int x;     // x is an L-value
*x = 10;  // *x is an L-value
array[5] = 20;  // array[5] is an L-value

int x = 7;     // 7 is an R-value
x = 10;       // x is an L-value being assigned an R-value
std::string s("Hello");  // "Hello" is an R-value
```

- On ne peut comparer des pointeurs de different types

### Conversion de pointers

```cpp
double* p;
int* o = (int*)p;

static_cast<int*>(p);
```

- Pas de conversion implicite de pointeurs
- Mais la conversion est possible si c'est a `void*`

### delete

- Liberer de la memoire dynamiquement allouer

```cpp
int* adi;
adi = new int[2];
adi[0] = 2;

delete adi;
```

### Pointer sur des fonctions

```cpp
void f(double, int);

// type (*name) (params)
void (*ptr)(double, int);
```

## OOP

## structures - Struct

- Une ensemble de valeur pouvant etre de type differents

```cpp
struct enreg {
    int numero;
    int qte;
    float prix;
};

enreg un;
un.numero = 0;
enreg deux = {0, 10, 4};
```

```cpp
const enreg REF = { 1, 10, 1. };
REF.qte = 0; // interdit
```

### Unions

- L’union permet théoriquement de faire partager un même emplacement mémoire par des variables de types différents.

```cpp
union essai {
    long n;
    float x;
}u;
```

### #Enumerations - enum

• Un type énumération est un cas particulier de type entier et donc un type scalaire (ou simple).

- On peut pas changer leur valeur

```cpp
enum couleur { jaune, rouge, bleu, vert };

couleur c1, c2;
c1 = jaune;
```

### typedef

- Utiliser pour definir un type

```cpp
typedef int Counter;
Counter i, j;
```

#### auto et decltype

- `auto` peut être utilisé pour demander au compilateur de déduire un type de l'initialisation.
  • `decltype` peut être utilisé pour faire la même chose mais sans l’initialisation de la nouvelle variable.

```cpp
int i = 3;
const int ci = 2;
auto a = i; // a est un int, initialisé à 3
auto b = ci; // b est un int, initialisé à 2
const auto c = ci; // c est un int constant, initialisé à 2

decltype(i) d; // d est un int. decltype(i) -> typeof(var) var_name = value;
decltype(ci) dd = 3; // dd est un int const, nécessite une initialisation.
```

## Classe

- Une classe est une `structure` dans laquelle seulement certains membres et/ou fonctions membres seront « publics » (accessibles « de l’extérieur »), les autres membres étant dits « privés ». La déclaration d’une classe est voisine de celle d’une structure. Il suffit :
  – de remplacer le mot clé struct par le mot clé class ;
  – de préciser quels sont les membres publics (fonctions ou données) et les membres privés en utilisant les mots clés public et private.

```cpp
#include <iostream>
using namespace std;
class Point {
    /* déclaration des membres privés */
    private: /* facultatif */
        int x;
        int y;
    /* déclaration des membres publics */
    public:
        void initialise(int, int);
        void deplace(int, int);
        void affiche();
};

/* ----- Définition des fonctions membres de la classe Point ---- */
void Point::initialise(int abs, int ord) {
    x = abs; y = ord;
}
void Point::deplace(int dx, int dy) {
    x = x + dx; y = y + dy;
}
void Point::affiche() {
    cout << "Je suis en " << x << " " << y << "\n";
}

int main() {
    Point a, b;
    a.initialise(5, 2); a.affiche();
    a.deplace(-2, 4); a.affiche();
    b.initialise(1, -1); b.affiche();
}
```

- `NOTE`: les attributs d'une classe sont par defaut prive.

```cpp
class Point {
    int x;
    public:
        int y;
};

Point a, b;
b.x = a.x; // illégal, puisque x est privé
b.y = a.y; // légal, car y est public
```

## Constructeur et destructeur

- `Constructeur`: Un constructeur est une fonction membre exécutée lors de la déclaration d’un objet statique, automatique, ou dynamique
- Le constructeur porte le même nom que la classe.

```cpp
class Point {
    /* déclaration des membres privés */
    int x;
    int y;
    public: /* déclaration des membres publics */
        Point(int, int); // constructeur
        void deplace(int, int);
        void affiche();
};

/* ----- Définition des fonctions membre de la classe Point ---- */
Point::Point(int abs, int ord) {
    x = abs; y = ord;
}

// La déclaration suivante ne convient plus:
Point a; // ne convient plus

Point a(1, 3); //bon
```

```cpp
/* Si on définit une classe Point disposant d’un constructeur sans argument, la déclaration d’objets de
   type Point continuera de s’écrire de la même manière que si la classe ne disposait pas de constructeur : */
Point a; // déclaration utilisable avec un constructeur sans argument

// Et non :
Point a(); // incorrect
```

• Un constructeur peut être surdéfini ou posséder des arguments par défaut.

- Lorsqu’une classe ne définit aucun constructeur, tout se passe comme si elle disposait d’un « constructeur par défaut » ne faisant rien

– Le `destructeur` est une fonction membre exécutée (si elle existe !) «à la fin de vie» d’un objet
statique, automatique, ou dynamique.
– On ne peut passer des paramètres au destructeur.
– Le destructeur porte le même nom que la classe, précédé d’un tilde (~).

```cpp
class Test {
    public:
        int num;
        Test(int); // constructeur
        ~Test(); // destructeur
};

Test::Test(int n) { // définition constructeur
    num = n;
    cout << "++ Appel constructeur - num = " << num << "\n";
}

Test::~Test() { // définition destructeur
    cout << "-- Appel destructeur - num = " << num << "\n";
}
```

#### Exemple

```cpp
#include <iostream>
#include <cstdlib> // pour la fonction rand
using namespace std;
class Hasard {
    int val[10];
    public:
        Hasard(int);
        void affiche();
};
Hasard::Hasard(int max) { // constructeur : 10 valeurs au hasard entre 0 et max
    int i;
    for (i = 0; i < 10; i++) val[i] = double(rand()) / RAND_MAX * max;
    /* rand() fournit un entier entre 0 et RAND_MAX (32767)*/
}
void Hasard::affiche() { // pour afficher les 10 valeurs
    int i;
    for (i = 0; i < 10; i++) cout << val[i] << " ";
    cout << "\n";
}
```

- Dynamique

```cpp
#include <iostream>
#include <cstdlib> // pour la fonction rand
using namespace std;
class Hasard {
    int nbval; // nombre de valeurs
    int* val; // pointeur sur les valeurs
    public:
        Hasard(int, int); // constructeur
        ~Hasard(); // destructeur
        void affiche();
};

Hasard::Hasard(int nb, int max) {
    int i;
    val = new int[nbval = nb];
    for (i = 0; i < nb; i++) val[i] = double(rand())/RAND_MAX*max;
}

Hasard ::~Hasard() {
    delete val;
};

void Hasard::affiche() { // pour afficher les nbval valeurs
    int i;
    for (i = 0; i < nbval; i++) cout << val[i] << " ";
    cout << "\n";
};
```

- Il y a destructeur par defaut mais il ne libere pas les parties dynamque. Alors, il faut tjrs creer un destructeur si on a des variables dynamque.

### Règles

– Un constructeur peut comporter un nombre quelconque d’arguments, ou aucun.
– Un constructeur ne renvoie pas de valeur ; aucun type ne peut figurer devant son nom (ici la présence de void est une erreur).
– Un destructeur ne peut disposer d’arguments et ne renvoie pas de valeur. Là encore, aucun type ne peut figurer devant son nom (et la présence de void est une erreur).
– Constructeurs et destructeurs peuvent être publics ou privés. En pratique, à moins d’avoir de bonnes raisons de faire le contraire, il vaut mieux les rendre publics.
– Si un destructeur est privé, il ne pourra plus être appelé directement (rare).

### Membres données statiques

- Une façon de permettre à plusieurs objets de partager des données consiste à déclarer avec le qualificatif static les membres données qu’on souhaite voir exister en un seul exemplaire pour tous les objets de la classe.

```cpp
class Exple {
    static int n;
    float x;
    ...
};
```

### Initialisation des membres données statiques

– Comme les membres données statiques n’existent qu’en un seul exemplaire, indépendamment des objets de la classe, leur initialisation ne peut plus être faite par le constructeur de la classe.
– Un membre static doit être initialisé explicitement (à l’extérieur de la déclaration de la classe) par :

```cpp
`int Exple::n = 5;
```

Cette démarche est utilisable aussi bien pour les membres statiques PRIVÉS que publics.

### Remarque

– Les membres statiques constants peuvent également être initialisés au moment de leur déclaration. Mais il est nécessaire de les déclarer à l’extérieur de la classe (sans valeur), pour provoquer la réservation de l’emplacement mémoire correspondant.

```cpp
class Exple1 {
    static const int n = 5; // initialisation OK (depuis la norme ANSI)
    .....
}

const int exple1::n; // déclaration indispensable (sans valeur)
```

### Inclusion multiple

```cpp
#ifndef POINT_H
#define POINT_H
// déclaration de la classe Point
#endif
```

### Fonctions membre

- Surdéfinition des fonctions membres
  – C++ autorise à surdéfinir les fonctions membres, y compris les constructeurs, de la même manière que les fonctions ordinaires.

```cpp
class A {
    public: void f(int);
    private: void f(char);
};
int main() {
    int n; char c;
    A a;
    a.f(c);
}
```

– Les fonctions membres peuvent disposer d’arguments par défaut.

```cpp
class Point {
int x, y;
    public:
        Point(); // constructeur 1 (sans argument)
        Point(int); // constructeur 2 (un argument)
        Point(int, int); // constructeur 3 (deux arguments)
        void affiche(const char* = ""); // un argument par défaut
};
```

### Fonctions membres en ligne

```cpp
class Point {
    int x, y;
    public:
        Point() { x = 0; y = 0; } // constructeur 1 "en ligne"
        Point(int abs) { x = y = abs; } // constructeur 2 "en ligne"
        Point(int abs, int ord) { x = abs; y = ord; } // constructeur 3 "en ligne"
        void affiche(const char* = "");
};
```

```c
class Point {
    public:
    inline Point();
};

inline Point::Point() { x = 0; y = 0; }
```

### Mode de transmission des objets en argument

```cpp
class Point {
    int x, y;
    public:
        Point(int abs = 0, int ord = 0) {
            x = abs; y = ord;
        } // constructeur ("en ligne")
        int coincide(Point*); // fonction membre coincide
};

int Point::coincide(Point* adpt) {
    if ((adpt->x == x) && (adpt->y == y)) return 1;
    else return 0;
}
```

### Les problèmes posés par la transmission par valeur

– Le transfert d’arguments par valeur présente les mêmes risques que l’affectation d’objets (dans le cas où ces objets possédaient des pointeurs sur des emplacements alloués dynamiquement), il s’agit également d’une simple recopie.
– De même que le problème posé par l’affectation peut être résolu par la surdéfinition de cet opérateur, celui posé par le transfert par valeur peut être réglé par l’emploi d’un constructeur particulier qu’on verra plus tard.

### Mot clet - this

- Reference a l'objet lui meme.
- C'est un argument implicite

### Fonctions membres statiques

– Les fonctions membres statiques ne recevront pas le pointeur sur l’objet this, comme pour les
autres fonctions membres. Mais, elles ne pourront accéder qu’aux données statiques de l’objet.

```cpp
class Entier {
    int i;
    static int j;
    public:
        static int get_value(void);
};

int Entier::j = 0;
int Entier::get_value(void){
j = 1; // Légal.
return i; // ERREUR ! get_value ne peut pas accéder à i.
}
```

### Fonctions membres constantes

– En C++, on peut définir des objets constants. Comme les opérations sont généralement réalisées par les fonctions membres, l’utilisateur doit préciser, parmi ces fonctions membres, lesquelles sont autorisées à opérer sur des objets constants, en utilisant le mot const dans leur déclaration.
– Exemple :

```cpp
class Point {
    int x, y;
    public:
        Point(...);
        void affiche() const;
        void deplace(...);
};
```

### Fonctions membre constantes

– Propriétés : Spécifier que la fonction affiche est constante a deux conséquences :

1. Elle est utilisable pour un objet déclaré constant (« Point constant »). La fonction deplace, qui n’a pas fait l’objet d’une déclaration const ne le sera pas. Ainsi, avec :

- Les instructions suivantes seront correctes :

```cpp
a.affiche () ;
c.affiche () ;
a.deplace (...) ;

// celle-ci sera rejetée par le compilateur :
c.deplace(...); // incorrect ; c est constant, alors que deplace ne l’est pas.

// La même remarque s’appliquerait à un objet reçu en argument :
void f(const Point p) { // ou même void f(const Point & p) - voir remarque
    p.affiche(); // OK
    p.deplace(...); // incorrect
}
```

2. Les instructions figurant dans sa définition ne doivent pas modifier la valeur des membres de l’objet Point :

```cpp
class Point {
    int x, y;
    public:
        void affiche() const {
            x++; // erreur car affiche a été déclarée const
        }
};
```

• Les membres statiques font exception à cette règle, car ils ne sont pas associés à un objet particulier :

```cpp
class Compte {
    static int n;
    public:
        void test() const{
            n++; //OK, bien que test soit déclarée constante, car n est statique
        }
};
```

– Remarques :
• On peut surdéfinir une fonction membre en se fondant sur la présence ou l’absence du qualificatif const. Dans Point :

```cpp
void affiche() const; // affiche I
void affiche(); // affiche II

//Avec ces déclarations :
Point a ;
const Point c ;

a.affiche(); //appele affiche II
c.affiche(); //appele afficehe I
```

### Membres mutables

– Une fonction membre constante ne peut pas modifier les valeurs des membres NON statiques.
– Le qualificatif mutable a cependant été introduit pour désigner des champs dont on accepte la modification, même par des fonctions membres constantes.
– Exemple :

```cpp
class Truc {
    int x, y;
    mutable int n; // n est modifiable par une fonction membre constante

    void f(.....) {
        x = 5; n++;
    } // rien de nouveau ici

    void f1(.....) const {
        n++; // OK car n est déclaré mutable
        x = 5; // erreur : f1 est const et x n’est pas mutable
    }
};

```

Exemple (suite):
• Les membres publics déclarés avec le qualificatif mutable sont modifiables par affectation :

```cpp
class Truc2 {
public:
    int n;
    mutable int p;
};

const Truc2 c;
c.n = 5; // erreur : l’objet c est constant et n n’est pas mutable
c.p = 5; // OK : l’objet c est constant, mais p est mutable

```

## Objets

### Objets automatiques et statiques

– Les objets automatiques sont ceux créés par une déclaration :
• dans une fonction : Ils sont détruits à la fin de l’exécution de la fonction.
• dans un bloc : ils sont détruits lors de la sortie du bloc.
– Les objets statiques sont ceux créés par une déclaration située :
• en dehors de toute fonction ;
• dans une fonction, mais assortie du qualificatif static.

- Les objets statiques sont créés avant le début de l’exécution de la fonction main et détruits après la fin de son exécution.
  – Construction et destruction :
  • le constructeur est appelé après la création de l’objet ;
  • le destructeur est appelé avant la destruction de l’objet.

### Object dynamique

```cpp
class Point {
int x, y;
public:
void initialise(int, int);
void deplace(int, int);
void affiche();
};

point *adr = new Point; //no constructor
delete adr;
```

#### Constructeur de copie (ou recopie)

- Permet d’initialiser un objet lors de son instanciation à partir d’un autre objet. Toute classe dispose d’un constructeur de copie par défaut généré automatiquement par le compilateur, dont le seul but est de recopier les champs de l’objet à recopier un à un dans les champs de l’objet à instancier. Toutefois, ce constructeur par défaut ne suffira pas toujours, et le programmeur devra parfois en fournir un explicitement. Ce sera le cas lorsque certaines données des objets auront été allouées dynamiquement. Une copie brutale des champs d’un objet dans un autre ne ferait que recopier les pointeurs, pas les données pointées. Ainsi, la modification int(const Point&);
- Si ce constructeur de recopie est privé, il n’est appelable que par des fonctions membres de la classe. (erreur de compilation).
  – Si on souhaite interdire la contruction par recopie, on peut :
  • le déclarer privé;
  • utiliser la possiblité offerte par C++ de déclarer une fonction sans en fournir de définition : dans ce cas toute tentative de copie (même par une fonction membre) sera rejetée ;
  • combiner les deux possibilités : effectuer une déclaration privée, sans définition ; dans ce cas, les tentatives de recopie par l’utilisateur resteront détectées en compilation (message explicite) et seules les recopies par une fonction membre se limiteront à une erreur d’édition de liens (et ce point ne concerne que le concepteur de la classe, pas son utilisateur !).

### Constructeur de recopie

```cpp
class Vect{
    int nelem; // nombre d’éléments
    double* adr; // pointeur sur ces éléments
    public:
    Vect(int n) { // constructeur "usuel"
        adr = new double[nelem = n];
        cout << "+ const. usuel - adr objet : " << this
        << " - adr vecteur : " << adr << "\n";
    }
    Vect(const Vect& v) { // constructeur de recopie
        adr = new double[nelem = v.nelem]; // création nouvel objet
        int i;
        for (i = 0; i<nelem; i++) adr[i] = v.adr[i];//recopie de l’ancien
        cout << "+ const. recopie - adr objet : " << this << " - adr vecteur : " << adr << "\n";
    }
    ~Vect() { // destructeur
        cout << "- Destr. objet - adr objet : "<< this << " - adr vecteur : " << adr << "\n";
        delete adr;
    }

void fct(Vect); // déclaration de la fonction ordinaire fct
Vect v1(5);
fct(v1); // appel de fct --> appel contructeur de recopie
Vect v2 = v1; // initialisation par appel constructeur de recopie
};
```

- On utilise reference car constructeur par valeur appelerait le constructeur qui causerait un recursion infini
- Le constructeur de recopie copie aussi l'addresse des parties dynamiques. Qui fait que si c'est un parametre d'une fonction, cette variable locale sera detruite qui fait que aussi notre objet originale voit aussi c'est partie dynamique detruite.

```cpp
#include <iostream>
using namespace std;

class Point{
    int* coords;
    public:
    Point(int x, int y){
        coords = new int[2];
        coords[0] = x;
        coords[1] = y;
    }
    ~Point(){
        cout << "deleting coords: (" << coords[0] << ", " << coords[2] << ")"<<endl;
        delete coords;
    }
}; //class is also a statement. Has to end with ;

void fn (Point b){
    cout << "calling fn" << endl;
} // b is delete with the reference to a.coords

int main(){
    Point p(1,2);
    fn(p);
    cout << "end of fn" << endl;
} // p.coords is freed again (double free). Segfault
```

```bash
calling fn
deleting coords: (1, 0)
end of fn
deleting coords: (-2018700888, 1876289933)
free(): double free detected in tcache 2
Aborted (core dumped)
```

### Initialisation d'un objet

```cpp
class Point {
    int x, y;
    public:
        Point(int abs) { x = abs; y = 0; }
};

Point a(1);
Point b = 2;
Point C = b;
Point d(a);
```

### Objets membres

```cpp
class Point {
    int x, y;
    public:
    int init(int, int);
    void affiche();
};

class Cercle {
    Point Centre;
    int rayon;
    public:
    void affrayon();
};

```

- L’objet c peut accéder classiquement à la méthode affrayon par c.affrayon. Mais, il ne pourra pas accéder à la méthode init du membre centre car centre est privé.

- On ne peut plus définir la classe Cercle précédente sans constructeur. On doit donc :
  • définir un constructeur pour Cercle ; et
  • spécifier les arguments à fournir au constructeur de Point : ceux-ci doivent être choisis obligatoirement parmi ceux fournis à Cercle :

```cpp
Cercle::Cercle(int abs, int ord, int ray) : centre(abs, ord) {...}
```

- La P.O.O.(Programmation Oriente Objet) pure impose l’encapsulation des données.
  • « l’unité de protection » en C++ est la classe, c’est-à-dire qu’une même fonction membre peut accéder à tous les objets de sa classe
  • Les membres privés (données ou fonctions) ne sont accessibles qu’aux fonctions membres (publiques ou privées) et seuls les membres publics sont accessibles « de l’extérieur ».

### Lecture 6 - Fonctions Amies

• Le principe d’encapsulation de la P.O.O. pure interdit à une fonction membre d’une classe d’accéder à des données privées d’une autre classe.
• La notion de fonction amie propose une solution intéressante, sous la forme d’un compromis entre encapsulation formelle des données privées et des données publiques.
• Lors de la définition d’une classe, il est possible de déclarer qu’une ou plusieurs fonctions (extérieures à la classe) sont des « amies » ; une telle déclaration d’amitié les autorise alors à accéder aux données privées.
• Il existe plusieurs situations d’amitiés :
– fonction indépendante, amie d’une classe ;
– fonction membre d’une classe, amie d’une autre classe ;
– fonction amie de plusieurs classes ;
– toutes les fonctions membres d’une classe, amies d’une autre classe.

```cpp
#include <iostream>
using namespace std;

class Point {
    int x, y;
    public:
        Point(int abs = 0, int ord = 0) { x = abs; y = ord; } // ("inline")
        friend int coincide(Point, Point); // fonction amie (indépendante)
};

// Aura access aux variables privees. (I) Fonction amie indépendante
int coincide(Point p, Point q) { // définition de coincide
    if ((p.x == q.x) && (p.y == q.y)) return 1;
    else return 0;
}

int main() {
    Point a(1, 0), b(1), c;
    if (coincide(a, b)) cout << "a coincide avec b \n";
    else cout << "a et b sont differents \n";
    if (coincide(a, c)) cout << "a coincide avec c \n";
    else cout << "a et c sont differents \n";
}
```

##### II. Fonctions membres amies

```cpp
class A
{
    // partie privée
    …
    // partie publique
    friend int B::f(char, A);
    …
};

class B {
    int f(char, A);
};

int B::f(char ..., A ...)
{ /*on a accès ici aux membres privés de tout objet de type A*/
}
```

#### III. Fonction amie de plusieurs classess

```cpp
class A {
// partie privée
…
// partie publique
friend void f(A, B) …
};

class B {
// partie privée
…
// partie publique
friend void f(A, B)
…
};

void f(A..., B...){
// on a accès ici aux membres privés de n’importe quel objet de type A ou B
}
```

#### IV. Toutes les fonctions membres d’une classe amies d’une autre classe

• On peut effectuer autant de déclarations d’amitié qu’il y a de fonctions concernées.
• Pour dire que toutes les fonctions membres de la classe B sont amies de la classe A, on placera, dans la classe A, la déclaration :

```cpp
class A{
    friend class B ;
}
```

### Surdefinition des operateurs

- La convention C++ pour surdéfinir cet opérateur + consiste à définir une fonction de nom : `operator +`
- La fonction operator + doit disposer de deux arguments de type Point et fournir une valeur de retour du même type

```cpp
#include <iostream>
using namespace std;
class Point {
    int x, y;
    public:
        Point(int abs = 0, int ord = 0) { x = abs; y = ord; } // constructeur
        friend Point operator + (Point, Point);
        void affiche() { cout << "coordonnees : " << x << " " << y << "\n"; }
};

Point operator + (Point a, Point b) {
    Point p;
    p.x = a.x + b.x; p.y = a.y + b.y;
    return p;
}

int main(){
    Point a, b, c;
    c = a + b;
    c = operator+(a, b); //on peut aussi ecrire comme ca
}
```

### Transmission par référence d’une valeur de retour

```cpp
int& f();
int n;
float x;
.....
f() = 2 * n + 5; // à la référence fournie par f, on range la valeur de l’expression
// 2*n+5, de type int
f() = x; //à la référence fournie par f, on range la valeur de x, après conversion en int

/// Valeur de retour et constance
int n = 3; // variable globale
float x = 3.5; // idem
int& f1(.....) {
    .....
    return 5; // interdit
    return n; // OK
    return x; // interdit. conversion se passe seulement si c'est constant
}

const int& f2(.....) {
    .....
    return 5; // OK : on renvoie la référence à une copie temporaire
    return n; // OK
    return x; //OK:on renvoie la référence à un int temporaire obtenu par conversion de la valeur de x
}
```

– On notera qu’une telle référence à une constante ne pourra plus être utilisée comme une lvalue :

```cpp
const int& f();
int n;
float x;

f() = 2 * n + 5; // erreur : f() n’est pas une lvalue pcq elle est constante
f() = x; // ne marche pas aussi

// on peut convertir le retour
int& f();
float x;
.....
x = f(); // OK : on convertira en float la valeur située à la référence reçue en
// retour de f
```

- Tous les opérateurs sont surdéfinissables, SAUF ` . , ::, ?`
- Une exception a lieu pour les seuls opérateurs new et delete dont la signification peut être modifiée de manière globale (pour tous les objets et les types de base).
- On ne peut surdéfinir un opérateur que s’il comporte au moins un argument (implicite ou non) de type classe. Il doit s’agir :
  - Fonction membres
  - Fonction amie
- Certains opérateurs doivent obligatoirement être définis comme membres d’une classe. Il s’agit de `[], ( ), ->`, ainsi que de new et delete (dans le seul cas où ils portent sur une classe particulière).

### Opérateurs ++ et --

```cpp
using namespace std;
class Point {
    int x, y;
    public:
    Point(int abs = 0, int ord = 0) {
        x = abs; y = ord;
    }
    Point operator ++ () { // notation préfixée. sans argument: ++p
        x++; y++;
        return *this; // `this` contient l'addresse de l'objet. `*this` is a dereference
    }

    // notation postfixée: p++
    Point operator ++ (int n) { //prend un parametre qui fait rien
        Point p = *this; // copie de l'objet qu'on va renvoyer. Previous_state
        x++; y++;
        return p;
    }

    void affiche() {
        cout << x << " " << y << "\n";
    }
};

```

#### Opérateur =

- C++ impose de surdéfinir l’opérateur = comme une fonction membre.

```cpp
class Vect {
    int nelem; // nombre d’éléments
    int* adr; // pointeur sur ces éléments
    public:
        Vect();
        ~Vect();
        Vect& operator = (const Vect&)
}
Vect& Vect::operator = (const Vect& v) { // noter const
    if (this != &v){
        delete adr;
        adr = new int[nelem = v.nelem];
        for (int i = 0; i < nelem; i++)
            adr[i] = v.adr[i];
    }
    return *this;
}
```

- Comme l’argument de la fonction membre operator = est transmis par référence, il est nécessaire de lui associer le qualificatif const si l’on souhaite pouvoir affecter un vecteur constant à un vecteur quelconque.

• Interdire l’affectation
– On peut avoir intérêt à interdire l’affectation de même que la recopie d’objets.
– Une redéfinition de l’affectation sous forme privée en interdit l’emploi par des fonctions autres que les fonctions membres de la classe concernée.
– C++ offre aussi la possibilité de déclarer une fonction sans en fournir de définition : dans ce cas, toute tentative d’affectation (même au sein d’une fonction membre) sera rejetée par l’éditeur de
liens.
– D’une manière générale, il est préférable de combiner les deux possibilités.
• Remarque
– On a utilisé la démarche la plus naturelle consistant à effectuer une copie profonde en dupliquant
la partie dynamique de l’objet. Dans certains cas, on pourra chercher à éviter cette duplication, en
la dotant d’un compteur de références.

### Forme canonique d’une classe (things each class should have in the least)

- il est nécessaire de munir la classe des quatre fonctions membres suivantes au moins :
  – constructeur (il sera généralement chargé de l’allocation de certaines parties de l’objet) ;
  – destructeur (il devra libérer correctement tous les emplacements dynamiques créés par l’objet) ;
  – constructeur de recopie ;
  – opérateur d’affectation.

```cpp
class T {
    public:
    T(...); // constructeurs autres que par recopie
    T(const T&); //constructeur de recopie (forme conseillée)
    //(déclaration privée pour l’interdire)
    ~T(); // destructeur
    T& operator = (const T&); // affectation (forme conseillée)
    ..... // (déclaration privée pour l’interdire)
};
```

- De prévoir une valeur de retour à l’opérateur d’affectation, seul moyen de gérer correctement les
  affectations multiples.

### Surdéfinition de l’opérateur [ ]

```cpp
class Vect{
    int nelem;
    int* adr;
    public:
        Vect(int n) { adr = new int[nelem = n]; }
        ~Vect() { delete adr; }
        int& operator [] (int);
};

int& Vect::operator [] (int i) const {
    return adr[i];
}

int& Vect::operator [] (int i) {
    return adr[i];
}

int main(){
    int i;
    Vect a(3), b(3), c(3);
    for (i = 0; i < 3; i++) {
        a[i] = i; //non-const function is called
        b[i] = 2 * i;
    }
    for (i = 0; i < 3; i++) c[i] = a[i] + b[i];
    for (i = 0; i < 3; i++) cout << c[i] << " ";
}
```

- C++ interdit de définir l’opérateur [] sous la forme d’une fonction amie ; il en est de même pour l’opérateur =.
  – Seules les fonctions membres dotées du qualificatif const peuvent être appliquées à un objet constant. L’opérateur [] ne permet donc pas d’accéder à un objet consta t, même s’il ne s’agit que d’utiliser la valeur de ses élements sans la modifier. On pourrait ajouter ce qualificatif const à l’opérateur [], mais la modification des valeurs d’un objet constant deviendrait alors possible, ce qui n’est guère souhaitable. On préférera définir un
  second opérateur destiné uniquement aux objets constants, en faisant en sorte qu’il puisse consulter l’objet en question sans le modifier. Ici, ce second opérateur serait :

```cpp
int Vect::operator [] (int i) const {
    return adr[i];
}
```

- On peut utiliser une fonction constante pour un objet non-constante mais pas l'inverse
- Une affectation telle que v[i] = ... ,v étant un vecteur constant, sera bien rejetée en compilation puisque notre opérateur transmet son résultat par valeur, et non plus par référence.

### Surdéfinition de l’opérateur ()

- Doit etre une fonction membre. Interdit ami

```cpp
class Cl_fct {
    public:
        Cl_fct(float x) { ..... }; // constructeur
        int operator() (int n, int p) { ..... } // opérateur ()
};
```

## Lecture 8

### Conversion de type

### Conversion simple

```cpp
int x = 10;
double y = double(x); // int(), float()
double z = static_cast<double>(x)
```

- Les conversions implicites sont mises en place par le compilateur et ne sont pas mentionnées par « l’utilisateur»

### Différentes sortes de conversions définies par l’utilisateur

```cpp
Point(int abs){x = abs; y=0;} // conversion d'un int en Point

class Point{
    public:
        operator int(){
            return x;
        }
        operator double();
        operator OtherClass();
}

int main(){
    Point a(3, 4), b(5, 7);
    int n1, n2;

    n1 = int(a); //appel explicite de int (). On peut aussi écrire: n1 = (int) a ou n1=static_cast<int> (a)
    cout << "n1 = " << n1 << "\n";

    n2 = b; // appel implicite de int()
    cout << "n2 = " << n2 << "\n";
}
```

- NOTE: Maximum une seule conversion utilisateurs a la fois

```cpp
// "At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value."

#include <string>

struct A {
    A( const std::string & s ) {}
};

void func( const A & a ) {
}

int main() {
    func( "one" );                  // error: const char* -> string -> A&
    func( A("two") );               // ok: Passed a valid A object
    func( std::string("three") );   // ok: implicit conversion. string -> A&
}
```

### Conversion type base -> classe

```cpp
class Point{
    int x, y;
    public:
        Point(int a){x = a, y = 0}
}

void func(Point);

int main(){
    Point a = Point(12);
    Point b = 13; // conversion implicite
    func(120);
}
```

### Interdire les conversion implicite

```cpp
class Point{
    public:
        explicit Point(int a);

}

int main(){
    Point a = 12 // Interdit
}
```

### Conversions d’un type classe en un autre type classe

```cpp
class Complexe;
class Point{
    int x, y;
    public:
        Point(int abs = 0, int ord = 0) { x = abs; y = ord; }
        operator Complexe (); // conversion Point --> Complexe
};

class Complexe{
    double reel, imag;
    public:
        Complexe(double r = 0, double i = 0) { reel = r; imag = i; }
        friend Point::operator Complexe ();
        void affiche() { cout << reel << " + " << imag << "i\n"; }
};

Point::operator Complexe (){
    Complexe r;
    r.reel = x; r.imag = y;
    cout << "cast " <<x<< " " <<y<< " en " << r.reel << " +" << r.imag <<"i\n";
    return r;
}

int main(){
    Point a(2, 5);
    Complexe c;

    c = (Complexe)a; c.affiche(); // conversion explicite

    Point b(9, 12);
    c = b; c.affiche(); // conversion implicite
}
```

### Conversion par un constructeur au lieu d'une classe

```cpp
class Point;
class Complexe{
    double reel, imag;
    public:
    Complexe(double r = 0, double i = 0) { reel = r; imag = i; }
    Complexe(Point);
    void affiche() { cout << reel << " + " << imag << "i\n"; }
};

class Point{
    int x, y;
    public:
    Point(int abs = 0, int ord = 0) { x = abs; y = ord; }
    friend Complexe::Complexe(Point);
};

Complexe::Complexe(Point p){
    reel = p.x;
    imag = p.y;
}
```

# Heritage simple

```cpp
class Point;
class PointCol: public Point{
    short couleur;
}
```

- Le mot `public` signifie que les membres publics de la classe de base (Point) seront des membres publics de la classe dérivée Pointcol.
- Chaque objet de type Pointcol peut alors faire appel :
  • aux méthodes publiques de Pointcol (ici colore) ;
  • aux méthodes publiques de la classe de base Point (initialise, deplace et affiche).
- Heritage public similaire au Java
- N'a pas acces au variable privee de la classe mere. Mais elle peut access au methode public

```cpp
void Pointcol::affichec(){
    Point::affiche(); // ou affiche
    cout << " et ma couleur est : " << couleur << "\n";
}
```

### Redéfinition des membres d’une classe derivee

• Redéfinition des fonctions membres d’une classe dérivée. - define une fonction avec le meme nom
• Redéfinition des données membres d’une classe dérivée

```cpp
class A {
    int a;
    char c;
    .....
};

class B : public A {
    float a;
    .....
};

b.a; // float a

// If int a was public
b.A::a;
```

- Le membre a défini dans B s’ajoute au membre a hérité de A ; il ne le remplace pas.

### Redéfinition et surdéfinition

- Lorsqu’une fonction est redéfinie dans une classe dérivée, elle masque une fonction de même signature (type de retour et parametre)
- Tous les fonctions herete sont masque

```cpp
class A {
    public:
        void f(int n) { ..... } // f est surdéfinie
        void f(char c) { ..... } // dans A
};

class B : public A {
    public:
    void f(float x) { ..... } // on ajoute une troisième définition dans B
};

int main() {
    int n;
    char c;
    A a;
    B b;
    a.f(n); // appelle A::f(int) (règles habituelles)
    a.f(c); // appelle A::f(char) (règles habituelles)
    b.f(n); // appelle B::f(float) (alors que peut-être A:f(int) conviendrait)
    b.f(c); // appelle B::f(float) (alors que peut-être A:f(char) conviendrait)
}
```

– Il est possible d’imposer que la recherche d’une fonction surdéfinie se fasse dans plusieurs classes en utilisant une directive using. Si dans la classe B précédente, on introduit (public) l’instruction :

```cpp
using A::f; // on réintroduit les fonctions f de A
```

### Appel des constructeurs et des destructeurs

```cpp
class A{
    public:
        A();
        ~A();
}

class B: public A{
    public:
        A();
        ~B();
}

int main(){
    B b; // appel A() et puis B()
} // appel ~B() et puis ~A()
```

- Transmission d’informations entre constructeurs

```cpp
class Point {
    int x, y;
    public:
        Point(int abs = 0, int ord = 0){
            cout << "++ constr. point : " << abs << " " << ord << "\n";
            x = abs; y = ord;
        }
        ~Point() {// destructeur de point
            cout << "-- destr. point : " << x << " " << y << "\n";
        }
};
class Pointcol : public Point {
    short couleur;
    public:
        Pointcol(int, int, short); // déclaration constructeur Pointcol
            ~Pointcol() {
            cout << "-- dest. pointcol - couleur : " << couleur << "\n";
        }
};

Pointcol::Pointcol(int abs = 0, int ord = 0, short cl = 1) : Point(abs, ord){
    cout << "++ constr. pointcol : " << abs << " " << ord << " " << cl << "\n";
    couleur = cl;
}
```

### Contrôle des accès

– Lors de la conception de la classe de base : en plus des statuts publics et privés, il existe un troisième statut dit « protégé » (protected). Les membres protégés se comportent comme des membres privés pour l’utilisateur de la classe dérivée mais comme des membres publics pour la classe dérivée elle-même (accessibles aux membres de la classe dérivée).

```cpp
class Point{
    protected:
        int x, y;
        public:
        Point(...);
        affiche();
        ....
};

class Pointcol : public Point{
    short couleur;
    public:
        void affiche() {
        cout << "Je suis en " << x << " " << y << "\n";
        cout << " et ma couleur est " << couleur << "\n";
    }
};
```

– Les fonctions amies d’une classe dérivée auront accès aux membres déclarés protégés dans sa classe de base.

- `NOTE`: les fonctions amies ne sont pas heritable

| Status    | Acces aux fonctions membres et amies de la classe derivee | Access a un utilisateur de la classe derivee | Nouveau statut dans la classe derivee |
| --------- | --------------------------------------------------------- | -------------------------------------------- | ------------------------------------- |
| public    | oui                                                       | oui                                          | public                                |
| protected | oui                                                       | non                                          | protected                             |
| private   | non                                                       | non                                          | private                               |

### Dérivation privée

- En utilisant le mot-clé private au lieu de public, il est possible d’interdire à un utilisateur d’une classe dérivée l’accès aux membres publics de sa classe de base. P

```cpp
class Point;
class PointCol : private Point {
    public:
        using Point:affiche(); // heriter cette methode
        Point::affiche();
}
```

- Si la classes appele de fonctions public de la classe mere. Ceci seront rejetées

### Dérivation protégée

- Les membres publics de la classe de base seront considérés comme protégés lors de dérivation.
  • Dans le cas d’une dérivation privée, les membres protégés de la classe de base restent accessibles aux fonctions membres et aux fonctions amies de la classe dérivée.
  • Les expressions dérivation publique et dérivation privée seront ambiguës dans le cas d’héritage multiple. Il faudra alors dire, pour chaque classe de base, quel est le type de dérivation (publique ou privée).
  | Classe de base | Dérivée publique | Dérivée protégée | Dérivée privé |
  | --- | --- | --- | --- |
  | **Statut initial** | Accès FMA | Accès utilisateur | Nouveau statut | Accès utilisateur | Nouveau statut | Accès utilisateur |
  | **public** | Oui | Oui | public | Oui | protégé | Non | privé | Non |
  | **protégé** | Oui | Non | protégée | Non | protégé | Non | privé | Non |
  | **privé** | Oui | Non | privé | Non | privé | Non | privé | Non |

## Conversion d’un type dérivé en un type de base

- On peut assigne un class fille a une classe mere (downgrade)
- On peut pas assigne un classe mere a une classe fille (upgrade)
- Meme chose pour les pointeurs

```cpp
Point *a = PointCol *b; // legal
PointCol *b = Point *a; // illegal
PointCol *b = static_cast<PointCol> a;
```

- casting pointers only changes the object beign pointed at. But this does not change the functions binding. When we call a function. The object will call the functions attributed to the type of the pointer not the actual type.

```cpp
Point * adp;
Point *adpc = new PointCol();
adp = adpc;
adp->affiche(); // calls Point.affiche not Pointcol. affiche.
```

- Pointer cast can also allow us to have access to private fields in parent class when the derived class does not have access. `Viol d'encapsulation`.

```cpp
class B: private A {}
A *ada = (A *)new B();
ada->private_fun_in_A(); //legal
```

## Heritage multiple

Lec 10

```cpp
class PointCoul : pubic Point, public coul {
    public:
        Pointcoul(int, int, int);
}

Pointcoul::Pointcoul(int abs, int ord, int cl) : Point(abs, ord), Coul(cl){
    cout << "++++ Constr. pointcoul \n";
}
```

- Ordre d'appel: `Point -> Coul -> PointCoul`
- Destructeur ordre: `PointCoul -> Coul -> Point` (ordre inverse des constructeurs)

### Classes virtuelles

```cpp
class A{
int x, y;
.....
};
class B : public A { ..... };
class C : public A { ..... };
class D : public B, public C{.....};
```

- `Probleme`: D herite de A deux fois

```cpp
class B : public virtual A { ..... };
class C : public virtual A { ..... };
class D : public B, public C { ..... };
```

• virtual apparaît ici dans B et C. Définir A comme « virtuelle » dans la déclaration de B signifie que A ne devra être introduite qu’une seule fois dans les descendants éventuels de A. Cette déclaration n’a guère d’effet sur les classes B et C elles-mêmes (si ce n’est une information « cachée » mise en place par le compilateur pour marquer A comme virtuelle au sein de B et C !). Avec ou sans le mot virtual, les classes B et C, se comportent de la même manière tant qu’elles n’ont pas de descendants.
• Le mot virtual peut être placé indifféremment avant ou après le mot public (ou le mot private).

```cpp
class E;
Class F;
class G: public virtual F;
class H: public virtual F;
class I : public G, pubic H;

class I{
    public:
        I(arg1);
}
I::I(arg1):F(arg1):G():H():E()
```

```cpp
#include <iostream>
using namespace std;
class Point {
    int x, y;
    public:
        Point(int abs, int ord) {
        cout << "++ Constr. point " << abs << " " << ord << "\n";
        x = abs; y = ord;
        }
        Point() // constr. par défaut nécessaire pour dérivations virtuelles
        {cout << "++ Constr. defaut point \n"; x = 0; y = 0;}
        void affiche() { cout << "Coordonnees : " << x << " " << y << "\n"; }
};
class Coul {
    short couleur;
    public:
        Coul(short cl) {cout << "++ Constr. coul " << cl << "\n";couleur = cl; }
        void affiche() { cout << "Couleur : " << couleur << "\n"; }
};

class Masse {
    int mas;
    public:
        Masse(int m) { cout << "++ Constr. masse " << m << "\n";mas = m; }
        void affiche() { cout << "Masse : " << mas << "\n"; }
};

class Pointcoul : public virtual Point, public Coul
{
    public:
        Pointcoul(int abs, int ord, int cl) : Coul(cl) {
            // pas d’info pour Point car dérivation virtuelle
            cout << "++++ Constr. pointcoul " << abs << " " << ord << " "
            << cl <<"\n";
        }
        void affiche() {
            Point::affiche();
            Coul::affiche();
        }
};

class Pointmasse : public virtual Point, public Masse {
    public:
        Pointmasse(int abs, int ord, int m) : Masse(m) // pas d’info pour Point car
        { //dérivation virtuelle
            cout << "++++ Constr. pointmasse " << abs << " " << ord << " "
            << m << "\n";
        }
        void affiche() {
            Point::affiche(); Masse::affiche();
        }
};

class Pointcolmasse : public Pointcoul, public Pointmasse {
    public:
        Pointcolmasse(int abs, int ord, short c, int m) : Point(abs, ord),
        Pointcoul(abs, ord, c), Pointmasse(abs, ord, m) {
        // infos abs ord en fait inutiles pour Pointcol et Pointmasse
         cout << "++++ Constr. pointcolmasse " << abs << " " << ord << " "
        << c << " " << m << "\n";
        }
        void affiche() {
            Point::affiche();
            Coul::affiche();
            Masse::affiche();
        }
};

int main(){
    Pointcoul p(3, 9, 2);
    p.affiche(); // appel de affiche de Pointcoul

    Pointmasse pm(12, 25, 100);
    pm.affiche();

    Pointcolmasse pcm(2, 5, 10, 20);
    pcm.affiche();
}
```

```bash
++ Constr. defaut point
++ Constr. coul 2
++++ Constr. pointcoul 3 9 2
Coordonnees : 0 0
Couleur : 2
++ Constr. defaut point
++ Constr. masse 100
++++ Constr. pointmasse 12 25 100
Coordonnees : 0 0
Masse : 100
++ Constr. point 2 5
++ Constr. coul 10
++++ Constr. pointcoul 2 5 10
++ Constr. masse 20
++++ Constr. pointmasse 2 5 20
++++ Constr. pointcolmasse 2 5 10 20
Coordonnees : 2 5
Couleur : 10
Masse : 20
```

### Les fonctions virtuelles et Polymophisme

Lec 11

• Un pointeur sur un type d’objet peut recevoir l’adresse de n’importe quel objet
descendant. À cet avantage s’oppose une lacune importante : l’appel d’une méthode pour un
objet pointé conduit à appeler la méthode correspondant au type du pointeur, et non pas au
type effectif de l’objet pointé lui-même.
• C++ réalise une ligature statique (typage statique). Le type d’un objet (pointé) y est
déterminé au moment de la compilation. Pour pouvoir obtenir l’appel de la méthode
correspondant au type de l’objet pointé, il est nécessaire que le type de l’objet ne soit pris en
compte qu’au moment de l’exécution (le type de l’objet désigné par un même pointeur pourra
varier au fil du déroulement du programme). On parle alors de ligature dynamique ou de
typage dynamique, ou de polymorphisme.
• Le polymorphisme peut être mis en oeuvre en utilisant les fonctions virtuelles.

```cpp
Point p;
PointCoul *adp = &p;
adp->affiche(); //appel Point::affiche parce que la ligature du pointeur est statique et etabli a la compilation (linking)

PointCoul pc;
adp = &pc;
adp-> affiche(); // appel toujours Point::affiche. Le pointeur est Point * alors linked to Point::affiched
```

- Solution: `Virtual functions`
- Les methodes virtuelles nous permet que le choix de fonctions se fasse durant l'execution non a la compilation
- `NOTE`: un pointeur parent peut pointe sur des objects enfants mais pas l'inverse

```cpp
class Point{
    public:
        Point();
        virtual void affiche();
}

Point
```

- Le constructeur et les fonctions ne peuvent pas etre virtuelles
- Le destructeur peut etre un fonction virtuelle

```cpp
class A {
public: ~A() { ..... }
.....
};
class B : public A{
public: ~B() { ...... } // la presence de virtual ici ne changerait rien
};
int main(){
A* a;
B* b;
b = new B();
a = b;
delete a; // a pointe sur un objet de type B mais on n’appelle que ~A
}
```

- L’appel de delete sur l’objet de type B pointé par a ne conduira qu’à l’appel du destructeur de A, lequel opère sur un objet de type B. Les conséquences peuvent être désastreuses. Deux démarches pour pallier cette difficulté :
  - soit interdire la suppression d’objets de type A : il suffit alors de ne pas placer de destructeur dans A, ou encore de le rendre privé ou protégé ;
  - soit placer dans A un destructeur virtuel (quitte à ce qu’il soit vide) ;
- Le destructeur sera peut etre appele deux fois

- Solution:

```cpp
class A {
public:
virtual ~A() { ..... }
.....
};
class B : public A{
public: ~B() { ...... } // la presence de virtual ici est facultative
};
int main(){
A* a;
B* b;
b = new B();
a = b;
delete a; // a pointe sur un objet de type B et on appelle bien ~B
}
```

- Les destructeurs des classes dérivées seront bien virtuels (même si le mot-clé virtual n’est pas rappelé, et bien que leurs noms soient différents d’une classe à sa dérivée). Ici, on appellera donc bien le destructeur du type B. On respecte la règle suivante :
- Dans une classe de base (destinée à être dérivée), prévoir :
  - soit aucun destructeur ;
  - soit un destructeur privé ou protégé ;
  - soit un destructeur public et virtuel.

### Cas particulier de l’opérateur d’affectation

- – L’opérateur d’affectation peut, comme toute fonction membre, être déclaré virtuel. Il faut bien
  voir que cette fonction est particulière, dans la mesure où la définition de l’affectation d’une classe
  B, dérivée de A ne constitue pas une redéfinition de l’opérateur d’affectation de A. Ce n’est donc
  pas une situation de polymorphisme.

```cpp
#include <iostream>
using namespace std;
class A{
public:
virtual void operator = (const A&){
cout << "affectation fictive A\n";
}
};
class B : public A{
public:
virtual void operator = (const B&) {
cout << "affectation fictive B\n";
}
};

int main() {
B* adb1 = new B;
B* adb2 = new B;
*adb1 = *adb2;
A* ada1 = new A;
A* ada2 = new A;
ada1 = adb1;
ada2 = adb2;
*ada1 = *ada2; // appelle affectation de A - virtual ne sert à rien car on ne redéfinit pas la même fonction
// L'operateure de recopie n'a pas etait surdefinit pour prendre une reference une variable B. Le pointer ada1 est liee avec la fonction de A seulement
}
```

```bash
/*SORTIE*/
affectation fictive B
affectation fictive A
```

### Les fonctions virtuelles pures pour la création de classes abstraites

- classes destinées simplement à donner naissance à d’autres classes par héritage : `classes abstraites`
- les « fonctions virtuelles pures » facilitent la définition de classes abstraites : Ce sont des fonctions virtuelles dont la définition est nulle (0), et non vide. La fonction dessine de la classe Forme_geo est une fonction virtuelle pure si elle a la déclaration: `virtual void dessine(...) = 0;`
  – Une classe comportant au moins une fonction virtuelle pure est considérée comme abstraite et il n’est plus possible de déclarer des objets de son type.
  – Une fonction déclarée virtuelle pure dans une classe de base doit obligatoirement être redéfinie dans
  une classe dérivée ou déclarée à nouveau virtuelle pure ; dans ce dernier cas, la classe dérivée est
  elle aussi abstraite.

```cpp
#include <typeinfo> // pour typeid
Point p;
Pointcol pc;
Point* adp;
adp = &p;
cout << "type de adp : " << typeid (adp).name() << "\n";
cout << "type de *adp : " << typeid (*adp).name() << "\n";
adp = &pc;
cout << "type de adp : " << typeid (adp).name() << "\n";
cout << "type de *adp : " << typeid (*adp).name() << "\n";
```

### Utilisation du champ name de type_info

– Il existe un opérateur à un opérande nommé typeid fournissant en résultat un objet de type prédéfini `type_info`. Cette classe contient la fonction membre name(), qui fournit une chaîne de style C représentant le nom du type.
– De plus, la classe dispose de deux opérateurs binaires `==` et `!=` qui permettent de comparer deux types.

```bash
/*SORTIE*/
type de adp : class Point *
type de *adp : class Point
type de adp : class Point *
type de *adp : class Pointcol
```

– La norme n’impose pas le nom exact que doit fournir cet opérateur ; on n’est pas assuré que le nom de type sera toujours Point, Point _, Pointcol _ comme ici.

### Cast dynamiques

• On vient de voir qu’on sait agir sur l’objet pointé en fonction de son type, on peut connaître le type
exact de cet objet, mais le type proprement dit des pointeurs utilisés dans ce polymorphisme reste
celui défini à la compilation.
– Si l’on sait que adp pointe sur un objet de type Pointcol (dérivé de Point), on pourrait
souhaiter convertir sa valeur en un pointeur de type Pointcol \*.
• C’est possible à l’aide d’opérateurs cast dynamiques. Avec l’hypothèse précédente (adp pointe
réellement sur un objet de type Pointcol), on peut écrire :

```cpp
Pointcol* adpc = dynamic_cast <Pointcol*> (adp);
```

• En compilation, la seule vérification qui sera faite est que cette conversion est (peut-être) acceptable car
l’objet pointé par adp est d’un type Point ou dérivé et Pointcol est lui-même dérivé de Point.
Mais ce n’est qu’au moment de l’exécution qu’on saura si la conversion est réalisable ou non.
Par exemple, si adp pointait sur un objet de type Point, la conversion échouerait.
• L’opérateur dynamic_cast aboutit si l’objet réellement pointé est, par rapport au type d’arrivée
demandé, d’un type identique ou d’un type descendant (dans un contexte de polymorphisme, c.à.d,
il doit exister au moins une fonction virtuelle).
Lorsque l’opérateur n’aboutit pas :

- il fournit le pointeur 0 s’il s’agit d’une conversion de pointeur ;
- il déclenche une exception bad_cast s’il s’agit d’une conversion de référence.

```cpp
int main(){
    A a; B b; C c;
    A* ada, * ada1;
    B* adb, * adb1;
    C* adc;

    ada = &a;//ada de type A* pointe sur un A;
    //sa conversion dynamique en B* ne marche pas
    adb = dynamic_cast <B*> (ada); cout << "dc <B*>(ada) " << adb << "\n";

    ada = &b;//ada de type A* pointe sur un B; sa conversion dynamique en B* marche
    adb = dynamic_cast <B*> (ada); cout << "dc <B*> ada " << adb << "\n";

    // sa conversion dynamique en A* marche
    ada1 = dynamic_cast <A*> (ada); cout << "dc <A*> ada " << ada1 << "\n";

    // mais sa conversion dynamique en C* ne marche pas
    adc = dynamic_cast <C*> (ada); cout << "dc <C*> ada " << adc << "\n";

    adb = &b;
    // adb de type B* pointe sur un B; sa conversion dynamique en A* marche
    ada1 = dynamic_cast <A*> (adb); cout << "dc <A*> adb " << ada1 << "\n";

    // sa conversion dynamique en B* marche
    adb1 = dynamic_cast <B*> (adb); cout << "dc <A*> adb1 " << adb1 << "\n";

    // mais sa conversion dynamique en C* ne marche pas
    adc = dynamic_cast <C*> (adb); cout << "dc <C*> adb1 " << adc << "\n";
}
```

```bash
/*Résultats fourni par le programme*/
dc <B*>(ada) 00000000
dc <B*> ada 004FFCA0
dc <A*> ada 004FFCA0
dc <C*> ada 00000000
dc <A*> adb 004FFCA0
dc <A*> adb1 004FFCA0
dc <C*> adb1 00000000
```

# Lec 12

## Patron de fonctions

• Le « patron » (`template`) de fonctions (« fonction générique » ou « modèle de fonction »), permet d’écrire une seule fois la définition d’une fonction pour que le compilateur puisse automatiquement l’adapter à n’importe quel type
• La notion de « patron » de fonctions est à la fois plus puissante et plus restrictive que la surdéfinition de fonctions.
• La fonction mini suivante fournit le minimum de deux valeurs de même type reçues en arguments. Pour le type int, on a:

```cpp
int mini(int a, int b){
    if (a < b) return a; // ou return a < b ? a : b ;
    else return b;
}

```

• Pour le type float, :

```cpp
float mini(float a, float b){
    if (a < b) return a; // ou return a < b ? a : b ;
    else return b;
}
```

• Un patron de fonctions nous permet de fournir une seule définition :

```cpp
template <class T> T mini(T a, T b){
    if (a < b) return a; // ou return a < b ? a : b ;
    else return b;
}
```

- template <class T> précise que l’on a affaire à un patron (template) dans lequel apparaît un « paramètre de type » nommé T (T est un type quelconque). Le reste de l’en-tête : `T mini(T a, T b)`
  – Dans la définition d’un patron, on utilise le mot clé class pour indiquer en fait un type quelconque, classe ou non. On peut aussi utiliser le mot clé typename qui peut se subtituer à class :

```cpp
template <typename T> T mini(T a, T b) { ..... } // idem template <class T>
```

```cpp
#include <iostream>
using namespace std;

template <class T> T mini(T a, T b) // création d’un patron de fonctions
{
    if (a < b) return a; // ou return a < b ? a : b ;
    else return b;
}
int main()
{
    int n = 4, p = 12;
    float x = 2.5, y = 3.25;
    cout << "mini (n, p) = " << mini(n, p) << "\n";// int min(int,int)
    cout << "mini (x, y) = "<< mini(x, y)<< "\n"; // float min(float, float)
    /*
    SORTIE
    mini (n, p) = 4
    mini (x, y) = 2.5
    */

    const char* adr1 = "monsieur", * adr2 = "bonjour";
    cout << "mini (adr1, adr2) = " << mini(adr1, adr2);

    /*
    SORTIE
    mini (adr1, adr2) = monsieur // a comparer les addresses. monsieur a ete declarer avant
    */
}
```

```cpp
class Vect{
    int x, y;
    public:
    Vect(int abs = 0, int ord = 0) { x = abs; y = ord; }
    void affiche() { cout << x << " " << y; }
    friend int operator < (Vect, Vect);
};

int operator < (Vect a, Vect b) {
    return a.x * a.x + a.y * a.y < b.x* b.x + b.y * b.y;
}

int main() {
    Vect u(3, 2), v(4, 1), w;
    w = mini(u, v);
    cout << "mini (u, v) = "; w.affiche();
}

/*SORTIE*/
mini (u, v) = 3 2
```

- Template definition has to be done in a header file and prefixed with `export` to make it available to all compilation units

```
Although Standard C++ has no such requirement, some compilers require that all function templates need to be made available in every translation unit that it is used in. In effect, for those compilers, the bodies of template functions must be made available in a header file. To repeat: that means those compilers won't allow them to be defined in non-header files such as .cpp files.
```

- Forme canonique:

```cpp
template <class T, class U> (Type retour) fct(T a, T* b, U c) { ... }
```

```cpp
mini<int>(c, n);/* force l’utilisation de mini<int>, et donc la conversion de c
en int ; le résultat sera de type int */
mini<char>(q, n);/* force l’utilisation de mini<char>, et donc la conversion de
q et de n en char ; le résultat sera de type char */
```

```cpp
template <class T, class U> T fct(T x, U y, T z){
    return x + y + z;
}

int n = 1, p = 2, q = 3;
float x = 2.5, y = 5.0;
cout << fct(n, x, p) << "\n"; // affiche la valeur (int) 5
cout << fct(x, n, y) << "\n"; // affiche la valeur (float) 8.5
cout << fct(n, p, q) << "\n"; // affiche la valeur (int) 6
cout << fct(n, p, x) << "\n"; // erreur : pas de correspondance

fct<int, float>(n, p, x) // force l’utilisation de fct<int,float> et donc la
//conversion de p en float et de x en int
fct<float>(n, p, x) // force l’utilisation de float pour T ; U est déterminé par
//les règles habituelles, c’est-à-dire int (type de p) n sera converti en float
```

### Surdéfinition de patrons

```cpp
// patron numero I
template <class T> T mini(T a, T b){
    if (a < b) return a;
    else return b;
}
// patron numero II
template <class T> T mini(T a, T b, T c){
    return mini(mini(a, b), c);
}
```

### Patron de classes

```cpp
template <class T> class Point{
    T x; T y;
    public:
        Point(T abs = 0, T ord = 0);
        void affiche();
};

template <typename T> void Point <T>::affiche(){
    cout << "Coordonnées : " << x << " " << y << "\n";
}

int main (){
    Point <int> ai;
    Point <double> ad;
}
```

```cpp
template <class T, int n> class Tableau {
T tab[n];
public:
// .....
};
Tableau <int, 4> ti;
```

• spécialiser la classe elle-même, en fournissant une nouvelle définition ; cette seconde
possibilité peut s’accompagner de la spécialisation de certaines fonctions membres. Par
exemple, après avoir défini le patron template <class T> class Point, on pourrait définir une
version spécialisée de la classe Point pour le type char, en procédant ainsi :

```cpp
class Point <char>{ // nouvelle définition}
```

```cpp
template <class T, class U> class A { ..... }; // patron I
template <class T> class A <T, T*> { ..... }; // patron II
// Une déclaration telle que, A <int, float> a1 utilisera le patron I,
// tandis qu’une déclaration telle que, A<int, int *> a2 utilisera le patron II plus spécialisé.
```

### Paramètres par défaut

```cpp
template <class T, class U = float> class A { ..... };
template <class T, int n = 3> class B { ..... };
.....
A<int, long> a1; /* instanciation usuelle */
A<int> a2; /* équivaut à A<int, float> a2 ; */
B<int, 3> b1; /* instanciation usuelle */
B<int> b2; /* équivaut à B<int, 3> b2 ; */
```

### Patrons de fonctions membres

```cpp
class A{
    template <class T> void fct(T a) { ..... }
};

// Cette possibilité peut s’appliquer à une fonction membre d’un patron de classe :
template <class T> class A{
    template <class U> void fct(U x, T y); /* ici le type T est utilisé, mais il pourrait ne pas l’être */
};
```

- TODO: Summariza lec 13-14

## Exceptions

Lecture 15
• Une `exception` est une rupture de séquence déclenchée par une instruction throw, comportant une expression d’un type donné. Il y’a alors branchement à un ensemble d’instructions nommé gestionnaire d’exception, dont le nom est déterminé par la nature de l’exception. Chaque exception est caractérisée par un type, et le choix du bon gestionnaire se fait en fonction de la nature de l’expression mentionnée à throw.

```cpp
int& Vect::operator [] (int i) {
    if (i<0 || i>nelem){
        Vect_limite l(i);
        throw (l); //déclenche une exception de type Vect_limite
    }

    return adr[i];
}

Vect::Vect(int n){
    if (n <= 0) {
    Vect_creation c(n); // anomalie
    throw c;
    }

    adr = new int[nelem = n]; // construction normale
}

try {

} catch (Vect_limite l){
    cout << "exception limite \n";
    exit(-1);
} catch(Vect_creation c){
    cout<<"exception creation vect nb elem =" << c.nb << "\n";
    exit(-1);
}
```

- `Vect_limite.hors` = indice problematique
- Recherche d’un gestionnaire correspondant au type exact mentionné dans throw. Le qualificatif const n’intervient pas ici (il y a toujours transmission par valeur). Si l’expression mentionnée dans throw est de type T, les gestionnaires suivants conviennent

```cpp
class Vect_erreur { ..... };
class Vect_creation : public Vect_erreur { ..... };
class Vect_limite : public Vect_erreur { ..... };
void f(){
.....
throw Vect_creation(); // exception 1
.....
throw Vect_limite(); // exception 2
}

int main(){
try{
.....
f();
.....
}
catch (Vect_erreur e) { /* on intercepte ici exception_1 et exception_2 */ }
}
```

- Recherche d’un gestionnaire correspondant à un type quelconque représenté dans catch par des points de suspension (...).

```cpp
catch (...) { /* gestionnaire 2 (type quelconque)*/ }
```

### La fonction unexpected

- Une fonction peut spécifier les exceptions qu’elle est susceptible de déclencher sans les traiter (ou de traiter et de redéclencher par throw), à l’aide du mot clé throw, suivi, entre parenthèses, de la liste des exceptions concernées.

```cpp
void f() throw (A, B) { ..... } /* f est censée ne déclencher que des exceptions de type A et B */
// equivalent a:
void f(){
    try {.....}
    catch (A a) { throw; } /* l’exception A est retransmise */
    catch (B b) { throw; } /* l’exception B est retransmise */
    catch (...) { unexpected(); } /* les autres appellent unexpected */
}
```

Le comportement par défaut de unexpected n’est pas entièrement défini, et peut :
• soit appeler la fonction terminate (qui, par défaut appelle abort, ce qui met fin à l’exécution) ;
• soit redéclencher une exception prévue dans la spécification d’interface de la fonction concernée.

- Ceci permet à `unexpected` de déclencher une exception standard `bad_exception`. On peut fournir une propre fonction en remplacement de unexpected, en l’indiquant par `set_unexpected`. Là encore, cette fonction ne peut pas effectuer de retour; contrairement à la fonction se substituant à `terminate`, elle peut lancer une `exception à son tour`

```cpp
void f(int n) throw (int) {
double d = 0.0;
float f = 0;
try {
cout << "n = " << n << "\n";
switch (n) {
case 0: throw d;break;
case 1: throw n;break;
case 2: throw f;break;
}
}
catch (double) { cout << "exception double dans f\n"; }
cout << " suite du bloc try dans f et retour appelant \n";
}

```

```bash
/*Résultats fournis par le programme*/
Integer (0 to 2) : 0
n = 0
exception double dans f
suite du bloc try dans f et retour appelant
suite du block try de main
------------------------------------------------------------------
Integer (0 to 2) : 1
n = 1
exception int dans main
suite du block try de main
------------------------------------------------------------------
Integer (0 to 2) : 2
n = 2
// ...... ici : appel de abort (fin anormale)
----------------------------------------------------------------------
```

### Les exceptions standard

- La bibliothèque standard comporte quelques classes fournissant des exceptions spécifiques susceptibles d’être déclenchées par un programme. Certaines peuvent être déclenchées par des fonctions ou des opérateurs de la bibliothèque standard.
- Toutes ces classes dérivent d’une classe de base nommée exception et sont organisées suivant la
  hiérarchie suivante (fichier en-tête <stdexcept>) :

```
exception
    Logic_error
        domain_error (situations où les entrées sont en dehors du domaine sur lequel une opération est définie)
        invalid_argument
        length_error
        out_of_range
    runtime_error
        range_error
        overflow_error (situations où le résultat d'un calcul est trop grand pour le type de destination)
        underflow_error
    bad_alloc
    bad_cast
    bad_exception
    bad_typeid
```

– `bad_alloc` : échec d’allocation mémoire par new ;
– `bad_cast` : échec de l’opérateur dynamic_cast ;
– `bad_typeid` : échec de la fonction typeid ;
– `bad_exception` : erreur de spécification d’exception ; cette exception peut être déclenchée dans certaines implémentations par la fonction unexpected ;
– `out_of_range` : erreur d’indice ; cette exception est déclenchée par les fonctions at, membres des différentes classes conteneurs, ainsi que par l’opérateur [] du conteneur bitset ;
– `invalid_argument` : déclenchée par le constructeur du conteneur bitset ;
– `overflow_error` : déclenchée par la fonction to_ulong du conteneur bitset.

– la classe exception dispose d’une fonction membre `what` censée fournir comme valeur de retour un pointeur sur `une chaîne expliquant la nature de l’exception`. Cette fonction, `virtuelle` dans exception, doit être `redéfinie dans les classes dérivées` et elle l’est dans toutes les classes citées ci-dessus ;
– toutes ces classes disposent d’un constructeur recevant un argument de type chaîne dont la valeur pourra ensuite être récupérée par `what`.

```cpp
catch (range_error& re){
    cout << "exception : " << re.what() << "\n";
    exit(-1); }
}
```

### L’opérateur new (nothrow)

- new déclenche une exception bad_alloc en cas d’échec.
- Pour les versions anciennes, new fournissait un pointeur nul en cas d’échec. Avec la norme, on peut retrouver ce comportement en utilisant, au lieu de new, l’opérateur `new (nothrow)` ou `new(std::nothrow)`.

```cpp
adr = new (nothrow) int[taille];
if (adr == 0) {
    cout << "**** manque de memoire ****\n";
    exit(-1);
}
```

### Gestion des débordements de mémoire avec set_new_handler

- Par défaut, new déclenche une exception `bad_alloc` en cas d’échec. Mais il est possible de définir une fonction de notre choix qui sera `appelée en cas de manque de mémoire`, en appelant la fonction `set_new_handler` et lui fournissant, en argument, `l’adresse de la fonction` qu’on a prévue pour traiter le cas de manque de mémoire. Voici comment adapter l’exemple précédent :

```cpp
#include <cstdlib> // pour exit
#include <new> // pour set_new_handler
#include <iostream>
using namespace std;

int main(){
    void deborde(); // proto fonction appelée en cas manque mémoire
    set_new_handler(deborde);
    long taille;
    int* adr;
    int nbloc;
    cout << "Taille de bloc souhaitee (en entiers) ? ";
    cin >> taille;
    for (nbloc = 1; ; nbloc++) {
        adr = new int[taille]; cout << "Allocation bloc numero : " << nbloc << "\n";
    }
}

void deborde()
{ // fonction appelée en cas de manque mémoire
    cout << "Memoire insuffisante\n";
    cout << "Abandon de l’execution\n";
    exit(-1);
}
```

### Création d’exceptions dérivées de la classe exception

- C’est intéressant de créer ses propres classes dérivées de exception, pour au moins deux raisons :

1. On facilite le traitement ultérieur des exceptions, on est sûr d’intercepter toutes les exceptions avec
   le simple gestionnaire :

`catch (exception & e) { ..... }`

2. On peut s’appuyer sur la fonction `what`, à condition de la redéfinir de façon appropriée dans ses
   propres classes. Il est alors facile d’afficher un message explicatif concernant l’exception détectée, à
   l’aide du simple gestionnaire suivant :

```cpp
catch (exception & e) // référence pour bénéficier de la ligature dynamique de la fonction virtuelle what
```

```cpp
#include <stdexcept>
using namespace std;
class Mon_exception_1 : public exception{
    public:
        Mon_exception_1() {}
        const char* what() const { return "mon exception numero 1"; }
        //il est important de définir what sous la forme d’une fonction membre
        //constante, sous peine de ne pas la voir appelée.
};

```

- Creation d'erreur avec un message custom

```cpp
class my_exception : public exception {
    char* ad_text;
    public:
        my_exception(char* text) { ad_text = text; }
        const char* what() const { return ad_text; }
};
```

### Compléments sur les exceptions

#### Les problèmes posés par les objets automatiques

```cpp
void f(int n){
    try{
        Vect* v1 = new Vect(5); //allocation dynamique de v1 de type Vect de 5 éléments
        v1[n] = 0; // OK pour 0 <= n < 5 ; exception Vect_limite sinon
        delete v1;//v1 sera convenablement détruit en cas de fin normale du bloc try
    }
    catch (Vect_limite vl){...}//instructions de gestion de l’exception Vect_limite
     ..... // instructions exécutées dans tous les cas :
     ..... // s’il n’y a pas eu exception v1 a été détruit
     ..... // s’il y a eu exception, v1 n’a pas été détruit
}
```

- L’objet v1 n’est pas détruit dès lors qu’une exception de type Vect_limite a été déclenchée. On pourrait encore prévoir de le faire dans le gestionnaire catch (Vect_limite), et après cette destruction, redéclencher l’exception par throw.

#### Le concept de pointeur intelligent : la classe auto_ptr

- La plus importante ressource nécessaire à un programme est généralement la mémoire. Un outil C++ utilise les <<pointeurs intelligents>> pour gérer convenablement les situations d’exception.
- Les <<pointeurs intelligents>> sont procurés par le patron de classes auto_ptr. Ça consiste à associer, dans un objet de type auto_ptr, un objet pointé à la variable pointeur qui en contient l’adresse: si la variable devient hors de portée, on détruit automatiquement l’objet pointé. Il faut toute fois respecter une contrainte, à savoir n’associer un objet donné qu’à une seule variable pointeur à la fois. Après copie d’objets de type auto_ptr, seul l’objet recevant la copie reste donc associé à la partie pointée, l’autre en ayant perdu le lien. Ceci s’applique aussi bien au constructeur par recopie qu’à l’affectation.

```cpp
double* add;
.....
auto_ptr<double> apd1(add); // auto_ptr sur le double pointé par add
auto_ptr<double> apd2(new double); // auto_ptr sur un double qu’on a alloué dynamiquement

auto_ptr<double> apd; // auto_ptr sur un double. Creation sans initialisation
```

- Un seule pointeur automatique a `ownership` d'un pointeur i.e supprimer, modifier, mais on peut tjrs avoir plusieurs pointeurs automatique qui pointeent sur le meme objet mais un seule garde la propriete.

```cpp
int main(){
    auto_ptr<vector<int> > apvi2; //non initialisé
    {
         int v[] = { 1, 2, 3, 4, 5 };
        auto_ptr<vector<int> > apvi1(new vector<int>(v, v + 5));
         (*apvi1)[2] = 12;
         cout << (*apvi1)[1] << " " << (*apvi1)[2] << "\n"; // affiche 2 12
         apvi2 = apvi1; // apvi1 et apvi2 pointent sur le meme vector mais seul apvi2 est
         // proprietaire du vector pointé
         (*apvi2)[2] = 20; // OK
         cout << (*apvi2)[1] << " " << (*apvi2)[2] << "\n"; // affiche 2 20
    } // ici apvi1 n’existe plus, mais le vector pointé appartient à apvi2

    //cout << (*apvi1)[1] conduirait à une erreur de compilation
    cout << (*apvi2)[1] << " " << (*apvi2)[2] << "\n"; //affiche toujours 2 20
} // ici apvi2 n’existe plus et le vector pointé est détruit
```

# Generalite sur la bibliotheque standard

### Notion de conteneur

- vecteurs, listes, ensembles ou tableaux associatifs

```cpp
list <int> li; /* liste vide d’éléments de type int */
vector <double> vd; /* vecteur vide d’éléments de type double */
list <Point> lp; /* liste vide d’éléments de type point */
```

- les patrons de conteneurs sont paramétrés à la fois par le type de leurs éléments et par une fonction dite allocateur utilisée pour les allocations et les libérations de mémoire. Ce second paramètre possède une valeur par défaut.

```cpp
list <int, allocator<int> > li; /* ne pas oublier l’espace entre int> et > ; sinon, >>
représentera l’opérateur >>*/
vector <double, allocator<double> > vd;
list <Point, allocator<Point> > lp;
```

### Notion d’itérateur

• Un itérateur est un objet défini par la classe conteneur concernée qui généralise la notion du pointeur :
– un itérateur possède une valeur qui désigne un élément d’un conteneur ; un itérateur pointe sur un élément d’un conteneur ;
– un itérateur peut être incrémenté par l’opérateur ++, pour pointer sur l’élément suivant du même conteneur ; ceci n’est possible que, parce que les conteneurs sont toujours ordonnés suivant une certaine séquence ;
– un itérateur peut être déréférencé, comme un pointeur, en utilisant l’opérateur * ; par exemple, si it est un itérateur sur une liste de Points, *it désigne un Point de cette liste ;
– deux itérateurs sur un même conteneur peuvent être comparés par égalité ou inégalité. Tous les conteneurs fournissent un itérateur portant le nom iterator et possédant au minimum les propriétés ci-dessus correspondent à un itérateur unidirectionnel.
– décrémentation par l’opérateur -- ; comme cette possibilité s’ajoute alors à celle qui est offerte par ++, l’itérateur est alors dit bidirectionnel ;
– accès direct : si it est un tel itérateur, l’expression it+i a un sens ; souvent, l’opérateur [] est alors défini, de manière que it[i] soit équivalent à \*(it+i) ; et l’itérateur peut être comparé par inégalité.
– Il existe deux autres catégories d’itérateurs (entrée et sortie) d’usage plus limité.
– Il existe aussi des « adaptateurs d’itérateurs », qui permettent d’en modifier les propriétés ; comme l’itérateur de flux et l’itérateur d’insertion.

- Parcours directe:
- Les valeurs des itérateurs de fin consistent à pointer, non pas sur le dernier élément d’un conteneur, mais juste après. Si un conteneur est vide, begin() possède la même valeur que end(), de sorte que le canevas précédent fonctionne toujours convenablement.

```cpp
list<Point> lp;
list<Point>::iterator il; /* itérateur sur une liste de Points */
for (il = lp.begin(); il != lp.end(); il++)
{
    /* ici *il désigne l’élément courant de la liste de Points lp */
}
```

- Parcours inverse:
- Tous les conteneurs pour lesquels iterator est au moins bidirectionnel, disposent d’un second itérateur noté reverse_iterator. Construit à partir du premier, il permet d’explorer le conteneur suivant l’ordre inverse. La signification de ++ et --, appliqués à cet itérateur, est alors adaptée en conséquence ; il existe
  également des valeurs particulières de type reverse_iterator fournies par les fonctions membres rbegin() et rend() ; on peut dire que rbegin() pointe sur le dernier élément du conteneur, tandis que rend() pointe juste avant le premier.

```cpp
list<Point> lp;
list<Point>::reverse_iterator ril; /* itérateur inverse sur une liste de points */
for (ril = lp.rbegin(); ril != lp.rend(); ril++) {
/* ici *ril désigne l’élément courant de la liste de points lp */
}
```

### Intervalle d’itérateur

- Tous les conteneurs sont ordonnés, de sorte qu’on peut les parcourir d’un début jusqu’à une fin. On peut définir un intervalle d’itérateur en précisant les bornes sous forme de deux valeurs d’itérateurs

```cpp
vector<Point>::iterator ip1, ip2; /* ip1 et ip2 sont des itérateurs sur un vecteur de
Points */

/*
 * Si ip1 et ip2 possèdent des valeurs telles que ip2 soit « accessible » depuis ip1, i.e, après un
 * certain nombre d’incrémentations de ip1 par ++, on obtient la valeur de ip2.
*/
```

### Notion d’algorithme

- Les différents algorithmes sont fournis sous forme de patrons de fonctions, paramétrés par le type des itérateurs qui leurs sont fournis en argument.

```cpp
int n;
n = count (v.begin(), v.end(), 1) ; /* compte le nombre d’éléments valant 1 dans la séquence [v.begin(), v.end()), donc, dans tout le conteneur v */

// Pour compter le nombre d’éléments égaux à 1 dans une liste
n = count (l.begin(), l.end(), 1) ; /* compte le nombre d’éléments valant 1 dans la séquence [l.begin(), l.end()), autrement dit, dans tout le conteneur l */

// recopier un vecteur d’entiers dans une liste d’entiers
vector<int> v; /* vecteur d’entiers */
list<int> l; /* liste d’entiers */
copy(v.begin(), v.end(), l.begin()); /* recopie l’intervalle [v.begin(), v.end())  à partir de l’emplacement pointé par l.begin() */
```

### Itérateurs et pointeurs

- Les pointeurs usuels possèdent les propriétés d’un itérateur à accès direct. Cela leur permet d’être employés dans bon nombre d’algorithmes.

```cpp
int t[6] = { 2, 9, 1, 8, 2, 11 };
list<int> l;
.....
copy(t, t + 6, l.begin()); /* copie de l’intervalle [t, t+6) dans la liste l *
```

### Les différentes sortes de conteneurs

- Les conteneurs sont classés en deux catégories :
  - les `conteneurs en séquence` (séquentiels): Les éléments sont ordonnés (`vecteur, liste`). On peut parcourir le conteneur suivant cet ordre, insèrer ou supprimer un élément en un endroit choisi.
  - les conteneurs associatifs:
    • peuventt être illustrés par un répertoire téléphonique. On associe une valeur (numéro de téléphone, ...) à une clé (ici le nom). À partir de la clé, on accède à la valeur associée. Pour insérer un nouvel élément dans ce conteneur, il ne sera plus utile de préciser un emplacement.
    • un conteneur associatif n’est donc plus ordonné. Un tel conteneur devra être ordonné (pour efficacité), de façon `intrinsèque`, c’est-à-dire suivant un ordre qui n’est plus défini par le programme. Il reste toujours possible de parcourir séquentiellement les éléments d’un tel conteneur qui disposera toujours au moins d’un itérateur nommé iterator et des valeurs begin() et end(). Certaines opérations des conteneurs séquentiels peuvent s’appliquer à des conteneurs associatifs. Il n’y aura aucun risque à examiner séquentiellement chacun des éléments d’un conteneur associatif ; il y en aura, si l’on cherche à modifier séquentiellement les valeurs d’éléments existants, puisqu’on risque de perturber l’ordre intrinsèque du conteneur. ex: `Map<Key, Value>`

### Les conteneurs dont les éléments sont des objets

```cpp
vector<Point> v(3); /* construction d’un vecteur de 3 Points */
vector<Point> w(v); /* ou vector v = w ; */
```

### Fonctions, prédicats et classes fonctions

- `Fonction unaire`: Beaucoup d’algorithmes et certaines fonctions membres permettent d’appliquer une fonction donnée aux éléments d’une séquence (intervalle d’itérateur).

```cpp
int main(){
list<float> lf;
void affiche(float);
for_each(lf.begin(), lf.end(), affiche);
cout << "\n";
.....
}
void affiche(float x) {
cout << x << " ";
}


// equivalent a:
for (il = l.begin(); il != l.end(); il++)
cout << (*il) << " ";
cout << "\n";
```

#### Prédicats

- Un `prédicat` est une fonction qui renvoie une valeur de type `bool`. Compte tenu des conversions implicites qui sont mises en place automatiquement, cette valeur peut être entière, 0 (false) et tout autre valeur (true). On rencontrera des prédicats unaires (1 seul argument) et des prédicats binaires (2 arguments de même type). Certains algorithmes et certaines fonctions membres nécessiteront qu’on leur fournisse un prédicat en argument. Par exemple, l’algorithme find_if permet de trouver le premier élément d’une séquence vérifiant un prédicat passé en argument:

```cpp
int main() {
    list<int> l;
    list<int>::iterator il;
    bool impair(int);
    // …
    il = find_if(l.begin(), l.end(), impair); /* il désigne le premier élément de l vérifiant le prédicat impair */
}
bool impair(int n) /* définition du prédicat unaire impair */
{
    return n % 2;
}
```

### Classes et objets fonctions

#### Utilisation d’objet fonction comme fonction de rappel

– Certains algorithmes ou fonctions membres peuvent nécessiter une fonction quelconque en argument (« fonction de rappel ») pour évoquer qu’une fonction est amenée à appeler une autre fonction qu’on lui a transmise en argument. Cette fonction de rappel est prévue dans la définition du patron correspondant, non pas sous forme d’une fonction, mais sous forme d’un objet de type quelconque.
– Exemple : Le patron de fonction essai définit une famille de fonctions recevant en argument une fonction de rappel sous forme d’un objet fonction f de type quelconque. Les exemples d’appels de la fonction essai montrent qu’on peut lui fournir, comme fonction de rappel, soit une fonction usuelle, soit un objet fonction.

```cpp
#include <iostream>
using namespace std;
class cl_fonc /* definition d’une classe fonction */
{
    int coef;
    public:
        cl_fonc(int n) {
            coef = n;
        }

        int operator () (int p) {
            return coef * p;
        }
};

int fct(int n) { /* definition d’une fonction usuelle */
    return 5 * n;
}

template <class T>void essai(T f) { // définition de essai qui reçoit en
    cout << "f(1) : " << f(1) << "\n"; // argument un objet de type quelconque
    cout << "f(4) : " << f(4) << "\n"; // et qui l’utilise comme une fonction
}

int main(){
    essai(fct); // appel essai, avec une fonction de rappel usuelle
    essai(cl_fonc(3)); // appel essai, avec une fonction de rappel objet
    essai(cl_fonc(7)); // idem
}
```

```bash
/*Résultats*/
f(1) : 5
f(4) : 20
f(1) : 3
f(4) : 12
f(1) : 7
f(4) : 28
```

- Un algorithme attendant un objet fonction peut recevoir une fonction usuelle. On notera que la réciproque est fausse. C’est pourquoi tous les algorithmes ont prévu leurs fonctions de rappel sous forme d’objets fonctions.

### Classes fonctions prédéfinies

• Dans <functional>, il existe un certain nombre de patrons de classes fonctions correspondant à des prédicats binaires de comparaison de deux éléments de même type.

```cpp
// equal_to (==), not_equal_to (!=), greater (>), less (<), greater_equal (>=), less_equal (<=).
// modulus (%), minus (-), times (*), divides (/).
// logical_and (&&), logical_or (||), logical_not (!).
```

## Lecture 17 – Les conteneurs séquentiels

### La fonction membre assign

- Alors que l’affectation n’est possible qu’entre conteneurs de même type, la fonction assign permet d’affecter, à un conteneur existant, les éléments d’une séquence définie par un intervalle [debut, fin), à condition que les éléments désignés soient du type voulu (pas seulement d’un type compatible par affectation) :

```cpp
assign(début, fin) // fin doit être accessible depuis début

Point a(...);
list<Point> lp(...);
vector<Point> vp(...);
.....
lp.assign(vp.begin(), vp.end()); /* maintenant : lp.size() = vp.size() */
vp.assign(10, a); /* maintenant : vp.size()=10 */
char t[] = { "hello" };
list<char> lc(7, 'x'); /* lc contient : x, x, x, x, x, x, x */
.....
lc.assign(t, t + 5); /* lc contient maintenant : h, e, l, l, o */
lc.assign(3, 'z'); /* lc contient maintenant : z, z, z */
```

• La fonction clear

```cpp
// La fonction clear() vide le conteneur de son contenu.

vector<Point> vp(10); /* vp.size() = 10 */
.....
vp.clear(); /* appel du destructeur de chacun des Points de vp maintenant
vp.size() = 0 */
```

• La fonction swap

```cpp
// La fonction membre swap permet d’échanger le contenu de deux conteneurs de même type, comme :

vector<int> v1, v2;
.....
v1.swap(v2); /* ou : v2.swap(v1) ; */
```

### Comparaison de conteneurs

- Les conteneurs vector, deque et list disposent des opérateurs == et < ; et également de !=, <=, > et >=.
- Le rôle de == correspond à ce qu’on attend d’un tel opérateur, tandis que celui de < s’appuie sur une
  comparaison lexicographique, analogue à celle qui permet de classer des mots par ordre alphabétique.
  • L’opérateur == - Si c1 et c2 sont deux conteneurs de même type, leur comparaison par == sera vraie s’ils ont la même taille et si les éléments de même rang sont égaux. Si les éléments concernés sont de type classe, il sera nécessaire que cette dernière dispose elle-même de l’opérateur ==.
  • L’opérateur < - Il effectue une comparaison lexicographique des éléments des deux conteneurs. Il compare les éléments de même rang, par l’opérateur <, en commençant par les premiers, s’ils existent. Il s’interrompe dès que l’une des conditions suivantes est réalisée :
  – fin de l’un des conteneurs atteinte ; le résultat de la comparaison est vrai ;
  – comparaison de deux éléments fausse ; le résultat de la comparaison des conteneurs est alors faux.

```cpp
int t1[] = { 2, 5, 2, 4, 8 };
int t2[] = { 2, 5, 2, 8 };
vector<int> v1(t1, t1 + 5); /* v1 contient : 2 5 2 4 8 */
vector<int> v2(t2, t2 + 4); /* v2 contient : 2 5 2 8 */
vector<int> v3(t2, t2 + 3); /* v3 contient : 2 5 2 */
vector<int> v4(v3); /* v4 contient : 2 5 2 */
vector<int> v5; /* v5 est vide */

v2 < v1;/* faux */
v3 < v2;/* vrai */
v3 < v4;/* faux */
v4 < v3;/* faux */
v3 == v4;/* vrai */
v4 > v5;/* vrai */
v5 > v5;/* faux */
v5 < v5;/* faux */
```

- Insertion ou suppression d’éléments

```cpp
list<double> ld;
list<double>::iterator il;/*on suppose que il pointe correctement dans la liste ld */
ld.insert(il, 2.5); /* insère 2.5 dans ld, avant l’élément pointé par il */
ld.insert(ld.begin(), 6.7); /* insère 6.7 au début de ld */
ld.insert(ld.end(), 3.2); /* insère 3.2 en fin de ld */
ld.insert(il, 10, -1); /* insère 10 fois -1 avant l’élément pointé par il */
vector<double> vd(...);
ld.insert(ld.begin(),vd.begin(),vd.end());/*insère tous les éléments de vd en début de ld*/
```

- Suppression

```cpp
erase(position) /*supprime l’élément désigné par position – fournit un itérateur sur l’élément suivant ou sur la fin de la séquence*/
erase(début, fin) /*supprime les valeurs de l’intervalle [début, fin) – fournit un itérateur sur l’élément suivant ou sur la fin de la séquence*/

// example
list<double> ld;
list<double>::iterator il1, il2; /*on suppose que il1 et il2 pointent correctement
dans la liste ld et que il2 est accessible à partir de il1*/
ld.erase(il1, il2); /*supprime les éléments de l’intervalle [il1, il2) */
ld.erase(ld.begin()); /* supprime l’élément de début de ld */
```

• Les deux fonctions erase renvoient la valeur de l’itérateur suivant le dernier élément supprimé s’il en existe un ou sinon, la valeur end(). Par exemple, la construction suivante, dans laquelle il est un itérateur, de valeur convenable, sur une liste d’entiers ld :

```cpp
while (il = ld.erase(il) != ld.end());
// est équivalente à :
erase(il, ld.end());
```

- Cas des insertions/suppressions en fin : pop_back et push_back
  – S’il est possible de supprimer le premier élément d’un conteneur en appliquant erase à la position begin(), il n’est pas possible de supprimer le dernier élément d’un conteneur, en appliquant erase à la position end(). Un tel résultat peut s’obtenir en appliquant erase à la position rbegin().
  - La fonction membre pop_back() réalise cette opération ; si c est un conteneur, c.pop_back()est équivalente à c.erase(c.rbegin()).
    – De même, il existe une fonction push_back spécialisée d’insertion en fin. Si c est un conteneur, c.push_back(valeur) est équivalent à c.insert(c.end(), valeur).

### Le conteneur vector

```cpp
vector<int> v(10); /* vecteur de 10 éléments */
vector<int>::iterator iv = v.begin(); /* iv pointe sur le premier élément de v*/
*iv = 0; /* place 0 dans le premier élément de v */
iv += 3; *iv = 30; /* place 30 dans le quatrième élément de v */
iv = v.end() - 2; *iv = 70; /* place 70 dans la huitième position de v */
```

- – Accès par indice

```cpp
v[0] = 0; /* ou : v.at(0) = 0 ; */
v[3] = 30; /* ou : v.at(3) = 30 ; */
v[7] = 70; /*ou vi[v.size()-3] = 70 ; ou v.at(7) = 70 ; (v de taille 10)*/
```

- Cas de l’accès au dernier élément

```cpp
vector<int> v(10);
…
v.back() = 25; /* équivalent, quand v est de taille 10, à : v[9] = 25 ;
équivalent, dans tous les cas, à : v[v.size()-1] = 25 */
```

• Insertions et suppressions - Le conteneur vector dispose des possibilités générales d’insertion et de suppression. Leur `efficacité est médiocre` que dans les listes. vector dispose aussi de fonctions membres d’insertion ou de suppression du dernier élément :
– `push_back(valeur)` pour insérer un nouvel élément en fin ;
– `pop_back()` pour supprimer le dernier élément

```cpp
vector<int> v(5, 99); /* vecteur de 5 éléments valant 99 et v.size() = 5 */
v.push_back(10); /*ajoute un élément de valeur 10 : v.size() = 6 et v[5] = 10*/
v.push_back(20);/*ajoute un élément de valeur 20 : v.size() = 7 et v[6] = 20 */
v.pop_back(); /* supprime le dernier élément : v.size() = 6 */
```

#### Outils de gestion de l’emplacement mémoire d’un vecteur

- `size()` permet de connaître le nombre d’éléments d’un vecteur,
- `capacity()` fournit la taille potentielle du vecteur, i.e le nombre d’éléments qu’il pourra accepter, sans avoir à effectuer de nouvelle allocation. Dans le cas usuel où le vecteur est alloué sous forme d’un seul bloc, cette fonction en fournit simplement la taille.
- À tout instant, on a toujours `capacity() >= size()`.
- La différence `capacity()-size()` permet de connaître le nombre d’éléments qu’on pourra insérer dans un vecteur sans qu’une réallocation de mémoire soit nécessaire.
- La fonction membre `reserve(taille)` permet d’imposer la taille minimale de l’emplacement alloué à un vecteur à un moment donné. L’appel de cette fonction peut amener à une recopie de tous les éléments du vecteur en un autre emplacement. Une fois ceci accompli, tant que la taille du vecteur ne dépassera pas la limite allouée, on est assuré de limiter au maximum les recopies d’éléments en cas d’insertion ou de suppression. En cas d’insertion d’un nouvel élément, les éléments situés avant ne seront pas déplacés et les
  références ou itérateurs correspondants resteront valides.
- `max_size()` permet de connaître la taille maximale qu’on peut allouer au vecteur.
- `resize(taille)` permet de modifier la taille effective du vecteur, aussi bien dans le sens de l’accroissement que dans celui de la réduction. Il ne s’agit plus, ici, comme avec reserve, d’agir sur la taille de l’emplacement alloué, mais sur le nombre d’éléments du vecteur. Si l’appel de resize conduit à augmenter la taille du vecteur, on lui insère, en fin, de nouveaux éléments. Si, l’appel conduit à diminuer la taille du vecteur, on supprime, en fin, le nombre d’éléments voulus avec, appel de leur destructeur, s’il s’agit d’objets.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main(){
void affiche(vector<int>);
int i;
int t[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
vector<int> v1(4, 99); // vecteur de 4 entiers egaux à 99
vector<int> v2(7, 0); // vecteur de 7 entiers
vector<int> v3(t, t + 6); // vecteur construit a partir de t
cout << "V1 init = "; affiche(v1);
for (i = 0; i < v2.size(); i++) v2[i] = i * i;
v3 = v2;
cout << "V2 = "; affiche(v2);
cout << "V3 = "; affiche(v3);"\n" ;
v1.assign(t + 1, t + 6); cout << "v1 apres assign : "; affiche(v1);
cout << "dernier element de v1 : " << v1.back() << "\n";
v1.push_back(99); cout << "v1 apres push_back : "; affiche(v1);
v2.pop_back(); cout << "v2 apres pop_back : "; affiche(v2);
cout << "v1.size() : " << v1.size() << " v1.capacity() : "
<< v1.capacity() << " V1.max_size() : " << v1.max_size() << "\n"; 19
vector<int>::iterator iv;
iv = find(v1.begin(), v1.end(), 16); // recherche de 16 dans v1
if (iv != v1.end()) v1.insert(iv, v2.begin(), v2.end());
// attention, ici iv n’est plus utilisable
cout << "v1 apres insert : "; affiche(v1);
}
void affiche(vector<int> v) { // voir remarque ci-dessous
unsigned int i;
for (i = 0; i < v.size(); i++) cout << v[i] << " ";
cout << "\n";
}
```

```bash
/*SORTIE*/
V1 init = 99 99 99 99
V2 = 0 1 4 9 16 25 36
V3 = 0 1 4 9 16 25 36
v1 apres assign : 2 3 4 5 6
dernier element de v1 : 6
v1 apres push_back : 2 3 4 5 6 99
v2 apres pop_back : 0 1 4 9 16 25
v1.size() : 6 v1.capacity() : 6 V1.max_size() : 1073741823
v1 apres insert : 2 3 4 5 6 99
```

### Le conteneur deque

• Le conteneur deque offre des fonctionnalités assez voisines de celles de vector. Il permet toujours
l’accès direct à un élément quelconque. Il offre, en plus de l’insertion ou suppression en fin, une
insertion ou suppression en début, ce que ne permettait pas vector. Il ne faut pas en conclure que
deque est plus efficace que vector car cette possibilité supplémentaire se paie à différents niveaux :
– une opération sur un conteneur de type deque sera moins rapide que la même opération, sur un
conteneur de type vector ;
– certains outils de gestion de l’emplacement mémoire d’un conteneur de type vector, n’existent
plus pour un conteneur de type deque : on disposera bien de size() et de max_size(), mais plus de
capacity et de reserve
• Les fonctionnalités de deque sont celles de vector, auxquelles il faut ajouter les fonctions
spécialisées pour le premier élément :
– front(), pour accéder au premier élément ; elle complète la fonction back permettant l’accès au
dernier élément ;
– push_front(valeur), pour insérer un nouvel élément en début ; elle complète la fonction
push_back() ;
– pop_front(), pour supprimer le premier élément ; elle complète la fonction pop_back().

```cpp
#include <iostream>
#include <deque>
#include <algorithm>
using namespace std;
int main(){
void affiche(deque<char>);
char mot[] = { "xyz" };
deque<char> pile(mot, mot + 3); affiche(pile);
pile.push_front('a'); affiche(pile);
pile[2] = 't';
pile.push_front('b');
pile.pop_back(); affiche(pile);
deque<char>::iterator ip;
ip = find(pile.begin(), pile.end(), 'x');
pile.erase(pile.begin(), ip); affiche(pile);
}
void affiche(deque<char> p){
for (int i = 0; i < p.size(); i++) cout << p[i] << " ";cout << "\n";}
```

```bash
/*SORTIE*/
x y z
a x y z
b a x t
x t
```

### Le conteneur list

- Le conteneur list correspond au concept de liste doublement chaînée, et disposera d’un itérateur bidirectionnel permettant de parcourir la liste à l’endroit ou à l’envers. Les insertions ou suppressions sont plus efficaces par rapport aux deux classes vector et deque. Mais, le conteneur list ne dispose plus d’un itérateur à accès direct.
  Le conteneur list dispose des possibilités générales d’insertion et de suppression procurées par les
  fonctions insert et erase et décrites plus haut.
  On dispose aussi de fonctions spécialisées d’insertion en début push_front(valeur) ou en fin
  push_back(valeur) ou de suppression en début pop_front() ou en fin pop_back(), rencontrées dans les
  classes vector et deque.

```cpp
remove(valeur) // supprime tous éléments égaux à valeur

// Example
int t[] = { 1, 3, 1, 6, 4, 1, 5, 2, 1 }
list<int> li(t, t + 9); /* li contient : 1, 3, 1, 6, 4, 1, 5, 2, 1 */
li.remove(1); /* li contient maintenant : 3, 6, 4, 5, 2 */


remove_if(prédicat) // supprime tous les éléments répondant au prédicat
//example
bool est_paire(int n) {return !(n % 2);}
int t[] = { 1, 6, 3, 9, 11, 18, 5 };
list<int> li(t, t + 7); /* li contient : 1, 6, 3, 9, 11, 18, 5 */
li.remove_if(est_paire); /* li contient maintenant : 1, 3, 9, 11, 5 */
```

- Tri d’une liste

```cpp
list<int> li(...); /* on suppose que li contient : 1, 6, 3, 9, 11, 18, 5 */
li.sort(); /* maintenenant li contient : 1, 3, 5, 6, 9, 11, 18 */
sort(prédicat) //trie la liste en s’appuyant sur le prédicat binaire prédicat
list<int> li(...); /* on suppose que li contient : 1, 6, 3, 9, 11, 18, 5 */
```

- • Suppression des éléments en double

```cpp
unique() /*ne conserve que le premier élément d’une suite de valeurs consécutives égales (==)*/
unique(prédicat) /*ne conserve que le premier élément d’une suite de valeurs consécutives satisfaisant au prédicat binaire prédicat*/

//example
int t[] = { 1, 6, 6, 4, 6, 5, 5, 4, 2 };
list<int> li1(t, t + 9); /* li1 contient : 1 6 6 4 6 5 5 4 2 */
list<int> li2 = li1; /* li2 contient : 1 6 6 4 6 5 5 4 2 */
li1.unique(); /* li1 contient maintenant : 1 6 4 6 5 4 2 */
li2.sort(); /* li2 contient maintenant : 1 2 4 4 5 5 6 6 6 */
li2.unique() /* li2 contient maintenant : 1 2 4 5 6 */
```

• Fusion de deux listes

```cpp
merge(liste) /* fusionne liste avec la liste concernée, en s’appuyant sur l’opérateur < ; à la fin : liste est vide*/
merge(liste, prédicat) /*fusionne liste avec la liste concernée, en s’appuyant sur le prédicat binaire prédicat*/

//example
int t1[] = { 1, 6, 3, 9, 11, 18, 5 };
int t2[] = { 12, 4, 9, 8 };
list<int> li1(t1, t1 + 7);
list<int> li2(t2, t2 + 4);
li1.sort(); /* li1 contient : 1 3 5 6 9 11 18 */
li2.sort(); /* li2 contient : 4 8 9 12 */
li1.merge(li2); /* li1 contient maintenant: 1 3 4 5 6 8 9 9 11 12 18 et li2 est vide */
```

• Transfert d’une partie de liste dans une autre

```cpp
✓ splice(position, liste_or) // déplace les éléments de liste_or à position
char t1[] = { "xyz" }, t2[] = { "abcdef" };
list<char> li1(t1, t1 + 3); /* li1 contient : x y z */
list<char> li2(t2, t2 + 6); /* li2 contient : a b c d e f */
list<char>::iterator il;
il = li1.begin(); il++; /* il pointe sur le deuxième élément de li1 */
li1.splice(il, li2); /* li1 contient : x a b c d e f y z, et li2 est vide */


✓ splice(position, liste_or, position_or) /*déplace l’élément de liste_or
pointé par position_or à l’endroit position*/
char t1[] = { "xyz" }, t2[] = { "abcdef" };
list<char> li1(t1, t1 + 3); /* li1 contient : x y z */
list<char> li2(t2, t2 + 6); /* li2 contient : a b c d e f */
list<char>::iterator il1 = li1.begin();
list<char>::iterator il2 = li2.end(); il2--; /* pointe sur l’avant dernier*/
li1.splice(il1, li2, il2); /* li1 contient : f x y z et li2 : a b c d e */


✓ splice(position, liste_or, debut_or, fin_or) /*déplace l’intervalle
[debut_or, fin_or) de liste_or à l’emplacement position*/
char t1[] = { "xyz" }, t2[] = { "abcdef" };
list<char> li1(t1, t1 + 3); /* li1 contient : x y z */
list<char> li2(t2, t2 + 6); /* li2 contient : a b c d e f */
list<char>::iterator il1 = li1.begin();
list<char>::iterator il2 = li2.begin(); il2++;
li1.splice(il1, li2, il2, li2.end()); /* li1 contient : b c d e f x y z,
li2 : a */
```

## Les adaptateurs de conteneur : stack , queue, et priority_queue

### Stack

```cpp
stack <int, vector<int> > s1; /* pile de int, utilisant un conteneur vector */
stack <int, deque<int> > s2; /* pile de int, utilisant un conteneur deque */
stack <int, list<int> > s3; /*pile de int, utilisant un conteneur list */
```

- empty() : fournit true si la pile est vide ;
- size() : fournit le nombre d’éléments de la pile ;
- top() : accès à l’information située au sommet de la pile qu’on peut connaître ou modifier (sans la
- supprimer) ;
- push (valeur) : place valeur sur la pile ;
- pop() : permet de supprimer l’élément situé au sommet de la pile sans le renvoyer.

### • L’adaptateur queue

```cpp
queue <int, deque<int> > q1; /*queue de int, utilisant un conteneur deque */
queue <int, list<int> > q2; /*queue de int, utilisant un conteneur list */
```

- `empty()` : fournit true si la queue est vide ;
- `size()` : fournit le nombre d’éléments de la queue ;
- `front()` : accès à l’information située en tête de la queue, qu’on peut ainsi connaître ou modifier,sans la supprimer ;
- `back()` : accès à l’information située en fin de queue, qu’on peut ainsi connaître ou modifier, sans la supprimer ;
- `push (valeur)` : place valeur dans la queue ;
- `pop()` : permet de supprimer l’élément situé en tête de la queue sans le renvoyer

### priority_queue

```cpp
priority_queue <int, deque<int> > q1;
priority_queue <int, deque<int>, greater<int> > q2;
```

- On ne peut pas utiliser une `list()` car list n'a pas d'access direct necessaire pour le trier
- `empty()` : fournit true si la queue est vide ;
- `size()` : fournit le nombre d’éléments de la queue ;
- `push (valeur)` : place valeur dans la queue ;
- `top()` : accès à l’information située en tête de la queue qu’on peut connaître ou modifier (sans la supprimer) ; actuellement, nous recommandons de ne pas utiliser la possibilité de modification qui, dans certaines implémentations, n’assure plus le respect de l’ordre des éléments de la queue ;
- `pop()` : permet de supprimer l’élément situé en tête de la queue sans le renvoyer.

```cpp
#include <iostream>
#include <queue>
#include <deque>

using namespace std;

int main(){
    int i;
    priority_queue <int, deque<int>, greater<int> > q;
    q.push(10); q.push(5); q.push(12); q.push(8);
    cout << "tete de la queue : " << q.top() << "\n";
    cout << "on vide : ";

    for (i = 0; i < 4; i++) {
        cout << q.top() << " "; q.pop();
    }
}
```

```bash
/*SORTIE*/
tete de la queue : 5
on vide : 5 8 10 12
```

# END

### Exam

- 26 questions
- From lecture 5 to lecture 17
- Understand examples given

### Lec 18 - Maps

```cpp
map<char, int> m;

//example
#include <iostream>
#include <map>
using namespace std;
int main() {
    void affiche(map<char, int>);
    map<char, int> m;
    cout << "map initial : "; affiche(m);
    m['S'] = 5;/*la cle S n’existe pas encore, l’element est cree */
    m['C'] = 12; /* idem */
    cout << "map SC : "; affiche(m);
    cout << "valeur associee a la cle 'X' : " << m['X'] << "\n";
    cout << "map X : "; affiche(m);
    m['S'] = m['c']; /* on a utilise m['c'] au lieu de m['C'] ; */
    /* la cle 'c' est creee */
    cout << "map final : "; affiche(m);
}

void affiche(map<char, int> m)
{
    map<char, int> ::iterator im;
    for (im = m.begin(); im != m.end(); im++)
    cout << "(" << (*im).first << "," << (*im).second << ") ";
    cout << "\n";
}
```

```bash
/*SORTIE*/
map initial :
map SC : (C,12) (S,5)
valeur associee a la cle 'X' : 0
map X : (C,12) (S,5) (X,0)
map final : (C,12) (S,0) (X,0) (c,0)
```

### pair

```cpp
pair <int, float> p(3, 1.25) /*crée une paire formée d’un int de valeur 3 et
d’un float de valeur 1.25 */
p = pair<int, float>(4, 3.35); /* ici, les arguments peuvent être d’un
type compatible par affectation avec celui attendu */
p = make_pair(4, 3.35f); /* attention : 3.35f car le type des arguments sert
à instancier la fonction patron make_pair */

p.first = 4;
p.second = 3.35; /* ici 3.35 (double) sera converti en float */
```

```cpp
map <int, long> m1; /* clés de type int, valeurs de type long */
map <char, Point> m2; /* clés de type char, valeurs de type Point */
map <string, long> repert; /* clés de type string, valeurs de type long */
```

```cpp
#include <iostream>
#include <map>

using namespace std;

int main() {
    void affiche(map<char, int>);
    map<char, int> m;
    map<char, int>::iterator im;
    m['c'] = 10; m['f'] = 20; m['x'] = 30; m['p'] = 40;
    cout << "map initial : "; affiche(m);
    im = m.find('f'); /* ici, on ne verifie pas que im est != m.end() */
    cout << "cle 'f' avant insert : " << (*im).first << "\n";
    m.insert(make_pair('a', 5)); /* on insere un element avant 'f'*/
    m.insert(make_pair('t', 7)); /* et un element apres 'f' */
    cout << "map apres insert : "; affiche(m);
    cout << "cle 'f' apres insert : " << (*im).first << "\n";/*im -> 'f' */
    m.erase('c');
    cout << "map apres erase 'c' : "; affiche(m);
    im = m.find('p'); if (im != m.end()) m.erase(im, m.end());
    cout << "map apres erase int : "; affiche(m);
}
```

```cpp
void affiche(map<char, int> m)
{
    map<char, int>::iterator im;
    for (im = m.begin(); im != m.end(); im++)
    cout << "(" << (*im).first << "," << (*im).second << ") ";
    cout << "\n";
}
```

```bash
/*SORTIE*/
map initial : (c,10) (f,20) (p,40) (x,30)
cle 'f' avant insert : f
map apres insert : (a,5) (c,10) (f,20) (p,40) (t,7) (x,30)
cle 'f' apres insert : f
map apres erase 'c' : (a,5) (f,20) (p,40) (t,7) (x,30)
map apres erase int : (a,5) (f,20)
```
