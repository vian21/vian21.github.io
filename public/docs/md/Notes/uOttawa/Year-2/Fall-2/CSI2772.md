# Programmation en C++

Zhor Sebbani

## Lecture 1

### Difference entre C++ et java

1. Compilation: .obj vs .class
2. Conception:
   - C++ permet la Programmation Oriente Objet et procedurale
   - Java est purement oriente
3. Variable constante: const vs final
4. Methodes constantes:
   - C++: Le mot-clé const est placé après la déclaration de la méthode. Seules les méthodes constantes peuvent agir sur un objet constant
   - Java:
5. Conversion de type - C++: Toutes les conversions de type par
   affectation sont acceptées quitte à
   dégrader fortement l'information - Java: Seules les conversions qui relèvent
   de promotion numérique sont
   autorisées par affectation (les
   autres doivent être demandées
   explicitement)
6. Definition de classe:
   - C++: declarer dans un fichier .h distinct du fichier d'implimentation (.cpp)
7. Pointer: java n'a pas de pointeur
8. Instanciation d'dune classe:
   - Java: always use new and get reference to object not address
   - C++: 1. Declaration et 2. new
9. Instanciation - Constructeur par default
   - Java: parenthese obligatoire
   - C++ : parenthese non obligatoire

```c++
A a;
A * a = new A;
A * a = new A();
```

10. Gestion de memoire
11. Passage d'arguments:
12. Initialisation par defaut des champs d'un objet
    - Java: oui e.g 0, false, NULL
    - C++: non
13. Affectation d'objet
14. Valeurs d'argument par defaut: n'existe pas en java
15. Allocation de tableau
    - Java: tjrs dynamique
    - C++ : static ou dynamic

```c++
int t[10];
int * t = new int [10];
```

16. Taile d'une tableu
    - Java: access a la propriete .length
    - C++ n'a pas
17. Tableaux en memoire: - C++: En C++ les tableaux à plusieurs
    indices déclarés de manière statique
    sont contigus en mémoire
    Ex : int t [10][25] crée 250 cases
    contigües - Java: En Java les tableaux à plusieurs
    indices fractionnent la mémoire :
    int t [][] = new int [10][25] non
    contigus
18. Heritage: derivation
19. Heritage multiple: c++ oui, non en java
20. Constructeur d'une classe fille
    - Java: super
    - C++ `B::B( int arg1, double arg2):A(arg1)`
21. Derivations successive: C++ oui, java oui (super designe le constructeur de la classes directment successive)
22. Membres proteges:
23. Redefinition de methode:
24. Polymophisme:
25. Classes abstraites
26. Arguments de la ligne de commandes
27. Gestions des flux:
    - C++: graces aux operateurs << >>
    - Java: graces a des classes specialise

### Quelques fonctionnalités qui n'existent pas en C++

1. Super classe - Objet: Les objets en C++ n'herite pas d'une classes commune.
2. Classes et methodes finales

- Une méthode final ne peut pas être redéfinie dans une classe fille
- Une classe final ne peut plus être dérivée

3. Interface: pas d'interface en C++

- Programmation en C++: Edition -> Compilation -> Executtion

### Types elementaires

- int, long int, short int, unsigned int
- Float, double, long double
- char
- booll
- size_t

## Variables

```c
int p = 10;
int p(10);
const int p = 10;
```

```c++
#include <string>
string t;
string t = "something";
t.size() // get size of string
t[i]; //get char at index i
s + t; //Concatenate two strings

string ch(10, '*'); //creer un string avec 10 *;
```

- String is initialized to empty string by default
- string variable lives in the stack but its data may leave on the heap depending on the size.
- You can return a local string. The compiler will copy it and pass it by value

### Tableaux

- Peut inclure la taile ou pas

```c++
int tab[2][2] = {1,2,3,4}; //pas besoin de separer les elements, ils sont dans une memoire contigue et distribuer en respect avec la taille
```

- Variable automatique: constante definit dans un bloc ou une fonction
- Tableau statique: toutes les valeur d'initialisation sont des expressions constantes
- Tableau automatique: les valeurs d'initialisation ne sont pas constantes

```c++
#include <vector>

vector<type> name(n_elements, initialisation_v);
vecotr<int> t(100, 5);
vector<vector<int> > t(10, vector<int>(20)); // Dont forget space > > or it will considered as a stream(un flux)
```

- Post-incrementation, increment a la prochaine instruction.

### Division

- Arrondi au type le plus large

## Fontions

```c++
void swap (int &a, int& b);  // wil make the compile take the reference of given variables. Not a pointer

int main(){
    int a = 10;
    int b = 20;
    cout << "Before: a = " << a << " b = " << b <<endl;

    swap(a, b);           // pass variables as is. The compiler will only send the references to vars

    cout << "After: a = " << a << " b = " << b <<endl;
    return 0;
}

/// Can work on variables as if normal integers
void swap (int &a, int& b){
    int c;
    c = a;
    a = b;
    b = c;
}
```

## Custom namespaces

```c++
namespace mine{
    int N = 10;
    void greet(){
        std::cout << "hello" <<endl;
    }
}
```

### Portée, visibilité, durée de vie des variables

##### Portée d’un identificateur

• La portée d’un identificateur correspond aux parties du programme où cet identificateur peut être utilisé sans provoquer d’erreur à la compilation.
• La portée d’une variable globale ou d’une fonction globale est égale au programme.
• La portée d’une variable locale va de sa définition jusqu’à la fin de la première instruction composée ({...}) qui contient sa définition.

##### Visibilité

– La visibilité d’une variable dit quand elle est accessible.
– La visibilité est inclue dans la portée...

##### Durée de vie

– La durée de vie d’une variable correspond à la période depuis sa création à sa destruction.

### Variable locale Static

- Il est possible d’attribuer un emplacement permanent à une variable locale et de conserver ainsi sa valeur d’un appel au suivant. Il suffit de la déclarer static. Sa durée de vie est celle du programme.

```c++
#include <iostream>
using namespace std;
int main(){
    void fct();
    int n;
    for (n = 1; n <= 5; n++)
        fct();
}
void fct() {
    static int i;
    i++;
    cout << "appel numero : " << i << "\n";
}
```

```sh
/*SORTIE*/
appel numero : 1
appel numero : 2
appel numero : 3
appel numero : 4
appel numero : 5
```

### Valeurs par defaut des parametres

```c++
int max(int a, int b =0){
    if (a>b) return a ;
    else return b ;
}
```

### Surdéfinition de fonctions

– C++ permet la surdéfinition de fonctions (fonctions ayant le même nom mais des paramètres différents). Le choix de la bonne fonction est basé sur le type des arguments.

```c++
void process (int);
void process (double);

void test (int&);
void test (const int&);

int n = 10;
float x = 10.0;

test (n); // prototype I
test (x); //prototype II. Parce c q it does much test(int) therefore the convetion is to use it as a const
```

### Pointeurs

- Un pointer est une variable qui peut contenir l'addresse d'une autre choses c.a.d variables, fonctions, ...
- Le nom d'un tableau est un pointeur constant. Lorsqu'il est utilisé sans indice. Il represente le premier element dans le tableau

```c++
int tab[10];

tab = &tab[0];
tab + i = &tab[i]
*(tab +1) = tab[1];
```

- L-values (Locator values) are expressions that refer to a memory location 12. They represent objects that have an identifiable location in memory and can be modified
- R-values (Right values) are expressions that refer to a memory location but cannot be modified directly 12. They represent temporary objects or constants.

```c++
int x;     // x is an L-value
*x = 10;  // *x is an L-value
array[5] = 20;  // array[5] is an L-value

int x = 7;     // 7 is an R-value
x = 10;       // x is an L-value being assigned an R-value
std::string s("Hello");  // "Hello" is an R-value
```

- On ne peut comparer des pointeurs de different types

### Conversion de pointers

```c++
double* p;
int* o = (int*)p;

static_cast<int*>(p);
```

- Pas de conversion implicite de pointeurs
- Mais la conversion est possible si c'est a `void*`

### delete

- Liberer de la memoire dynamiquement allouer

```c++
int* adi;
adi = new int[2];
adi[0] = 2;

delete adi;
```

### Pointer sur des fonctions

```c++
void f(double, int);

// type (*name) (params)
void (*ptr)(double, int);
```

## OOP

## structures - Struct

- Une ensemble de valeur pouvant etre de type differents

```c++
struct enreg {
    int numero;
    int qte;
    float prix;
};

enreg un;
un.numero = 0;
enreg deux = {0, 10, 4};
```

```c++
const enreg REF = { 1, 10, 1. };
REF.qte = 0; // interdit
```

### Unions

- L’union permet théoriquement de faire partager un même emplacement mémoire par des variables de types différents.

```c++
union essai {
    long n;
    float x;
}u;
```

### #Enumerations - enum

• Un type énumération est un cas particulier de type entier et donc un type scalaire (ou simple).

- On peut pas changer leur valeur

```c++
enum couleur { jaune, rouge, bleu, vert };

couleur c1, c2;
c1 = jaune;
```

### typedef

- Utiliser pour definir un type

```c++
typedef int Counter;
Counter i, j;
```

#### auto et decltype

- `auto` peut être utilisé pour demander au compilateur de déduire un type de l'initialisation.
  • `decltype` peut être utilisé pour faire la même chose mais sans l’initialisation de la nouvelle variable.

```c++
int i = 3;
const int ci = 2;
auto a = i; // a est un int, initialisé à 3
auto b = ci; // b est un int, initialisé à 2
const auto c = ci; // c est un int constant, initialisé à 2

decltype(i) d; // d est un int. decltype(i) -> typeof(var) var_name = value;
decltype(ci) dd = 3; // dd est un int const, nécessite une initialisation.
```

## Classe

- Une classe est une `structure` dans laquelle seulement certains membres et/ou fonctions membres seront « publics » (accessibles « de l’extérieur »), les autres membres étant dits « privés ».
  La déclaration d’une classe est voisine de celle d’une structure. Il suffit :
  – de remplacer le mot clé struct par le mot clé class ;
  – de préciser quels sont les membres publics (fonctions ou données) et les membres privés en utilisant les mots clés public et private.

```c++
#include <iostream>
using namespace std;
class Point {
    /* déclaration des membres privés */
    private: /* facultatif */
        int x;
        int y;
    /* déclaration des membres publics */
    public:
        void initialise(int, int);
        void deplace(int, int);
        void affiche();
};

/* ----- Définition des fonctions membres de la classe Point ---- */
void Point::initialise(int abs, int ord) {
    x = abs; y = ord;
}
void Point::deplace(int dx, int dy) {
    x = x + dx; y = y + dy;
}
void Point::affiche() {
    cout << "Je suis en " << x << " " << y << "\n";
}

int main() {
    Point a, b;
    a.initialise(5, 2); a.affiche();
    a.deplace(-2, 4); a.affiche();
    b.initialise(1, -1); b.affiche();
}
```

- `NOTE`: les attributs d'une classe sont par defaut prive.

```c++
class Point {
    int x;
    public:
        int y;
};

Point a, b;
b.x = a.x; // illégal, puisque x est privé
b.y = a.y; // légal, car y est public
```

## Constructeur et destructeur

- `Constructeur`: Un constructeur est une fonction membre exécutée lors de la déclaration d’un objet statique, automatique, ou dynamique
- Le constructeur porte le même nom que la classe.

```c++
class Point {
    /* déclaration des membres privés */
    int x;
    int y;
    public: /* déclaration des membres publics */
        Point(int, int); // constructeur
        void deplace(int, int);
        void affiche();
};

/* ----- Définition des fonctions membre de la classe Point ---- */
Point::Point(int abs, int ord) {
    x = abs; y = ord;
}

// La déclaration suivante ne convient plus:
Point a; // ne convient plus

Point a(1, 3); //bon
```

```c++
/* Si on définit une classe Point disposant d’un constructeur sans argument, la déclaration d’objets de
   type Point continuera de s’écrire de la même manière que si la classe ne disposait pas de constructeur : */
Point a; // déclaration utilisable avec un constructeur sans argument

// Et non :
Point a(); // incorrect
```

• Un constructeur peut être surdéfini ou posséder des arguments par défaut.

- Lorsqu’une classe ne définit aucun constructeur, tout se passe comme si elle disposait d’un « constructeur par défaut » ne faisant rien

– Le `destructeur` est une fonction membre exécutée (si elle existe !) «à la fin de vie» d’un objet
statique, automatique, ou dynamique.
– On ne peut passer des paramètres au destructeur.
– Le destructeur porte le même nom que la classe, précédé d’un tilde (~).

```c++
class Test {
    public:
        int num;
        Test(int); // constructeur
        ~Test(); // destructeur
};

Test::Test(int n) { // définition constructeur
    num = n;
    cout << "++ Appel constructeur - num = " << num << "\n";
}
Test::~Test() { // définition destructeur
    cout << "-- Appel destructeur - num = " << num << "\n";
}
```

#### Exemple

```c++
#include <iostream>
#include <cstdlib> // pour la fonction rand
using namespace std;
class Hasard {
    int val[10];
    public:
        Hasard(int);
        void affiche();
};
Hasard::Hasard(int max) { // constructeur : 10 valeurs au hasard entre 0 et max
    int i;
    for (i = 0; i < 10; i++) val[i] = double(rand()) / RAND_MAX * max;
    /* rand() fournit un entier entre 0 et RAND_MAX (32767)*/
}
void Hasard::affiche() { // pour afficher les 10 valeurs
    int i;
    for (i = 0; i < 10; i++) cout << val[i] << " ";
    cout << "\n";
}
```

- Dynamique

```c++
#include <iostream>
#include <cstdlib> // pour la fonction rand
using namespace std;
class Hasard {
    int nbval; // nombre de valeurs
    int* val; // pointeur sur les valeurs
    public:
        Hasard(int, int); // constructeur
        ~Hasard(); // destructeur
        void affiche();
};

Hasard::Hasard(int nb, int max) {
    int i;
    val = new int[nbval = nb];
    for (i = 0; i < nb; i++) val[i] = double(rand())/RAND_MAX*max;
}

Hasard ::~Hasard() {
    delete val;
};

void Hasard::affiche() { // pour afficher les nbval valeurs
    int i;
    for (i = 0; i < nbval; i++) cout << val[i] << " ";
    cout << "\n";
};
```

- Il y a destructeur par defaut mais il ne libere pas les parties dynamque. Alors, il faut tjrs creer un destructeur si on a des variables dynamque.

### Règles

– Un constructeur peut comporter un nombre quelconque d’arguments, ou aucun.
– Un constructeur ne renvoie pas de valeur ; aucun type ne peut figurer devant son nom (ici la présence de void est une erreur).
– Un destructeur ne peut disposer d’arguments et ne renvoie pas de valeur. Là encore, aucun type ne peut figurer devant son nom (et la présence de void est une erreur).
– Constructeurs et destructeurs peuvent être publics ou privés. En pratique, à moins d’avoir de bonnes raisons de faire le contraire, il vaut mieux les rendre publics.
– Si un destructeur est privé, il ne pourra plus être appelé directement (rare).

### Membres données statiques

- Une façon de permettre à plusieurs objets de partager des données consiste à déclarer avec le qualificatif static les membres données qu’on souhaite voir exister en un seul exemplaire pour tous les objets de la classe.

```c++
class Exple {
    static int n;
    float x;
    ...
};
```

### Initialisation des membres données statiques

– Comme les membres données statiques n’existent qu’en un seul exemplaire, indépendamment des objets de la classe, leur initialisation ne peut plus être faite par le constructeur de la classe.
– Un membre static doit être initialisé explicitement (à l’extérieur de la déclaration de la classe) par :

```c++
`int Exple::n = 5;
```

Cette démarche est utilisable aussi bien pour les membres statiques PRIVÉS que publics.

### Remarque

– Les membres statiques constants peuvent également être initialisés au moment de leur déclaration. Mais il est nécessaire de les déclarer à l’extérieur de la classe (sans valeur), pour provoquer la réservation de l’emplacement mémoire correspondant.

```c++
class Exple1 {
    static const int n = 5; // initialisation OK (depuis la norme ANSI)
    .....
}

const int exple1::n; // déclaration indispensable (sans valeur)
```

### Inclusion multiple

```c++
#ifndef POINT_H
#define POINT_H
// déclaration de la classe Point
#endif
```

### Fonctions membre

- Surdéfinition des fonctions membres
  – C++ autorise à surdéfinir les fonctions membres, y compris les constructeurs, de la même manière que les fonctions ordinaires.

```c++
class A {
    public: void f(int);
    private: void f(char);
};
int main() {
    int n; char c;
    A a;
    a.f(c);
}
```

– Les fonctions membres peuvent disposer d’arguments par défaut.

```c++
class Point {
int x, y;
    public:
        Point(); // constructeur 1 (sans argument)
        Point(int); // constructeur 2 (un argument)
        Point(int, int); // constructeur 3 (deux arguments)
        void affiche(const char* = ""); // un argument par défaut
};
```

### Fonctions membres en ligne

```c++
class Point {
    int x, y;
    public:
        Point() { x = 0; y = 0; } // constructeur 1 "en ligne"
        Point(int abs) { x = y = abs; } // constructeur 2 "en ligne"
        Point(int abs, int ord) { x = abs; y = ord; } // constructeur 3 "en ligne"
        void affiche(const char* = "");
};
```

```c
class Point {
    public:
    inline Point();
};

inline Point::Point() { x = 0; y = 0; }
```

### Mode de transmission des objets en argument

```c++
class Point {
int x, y;
public:
Point(int abs = 0, int ord = 0) {
x = abs; y = ord;
} // constructeur ("en ligne")
int coincide(Point*); // fonction membre coincide
};
int Point::coincide(Point* adpt) {
if ((adpt->x == x) && (adpt->y == y)) return 1;
else return 0;
}
```

### Les problèmes posés par la transmission par valeur

– Le transfert d’arguments par valeur présente les mêmes risques que l’affectation d’objets (dans le cas où ces objets possédaient des pointeurs sur des emplacements alloués dynamiquement), il s’agit également d’une simple recopie.
– De même que le problème posé par l’affectation peut être résolu par la surdéfinition de cet opérateur, celui posé par le transfert par valeur peut être réglé par l’emploi d’un constructeur particulier qu’on verra plus tard.

### Mot clet - this

- Reference a l'objet lui meme.
- C'est un argument implicite

### Fonctions membres statiques

– Les fonctions membres statiques ne recevront pas le pointeur sur l’objet this, comme pour les
autres fonctions membres. Mais, elles ne pourront accéder qu’aux données statiques de l’objet.

```c++
class Entier {
    int i;
    static int j;
    public:
        static int get_value(void);
};

int Entier::j = 0;
int Entier::get_value(void){
j = 1; // Légal.
return i; // ERREUR ! get_value ne peut pas accéder à i.
}
```

### Fonctions membres constantes

– En C++, on peut définir des objets constants. Comme les opérations sont généralement réalisées
par les fonctions membres, l’utilisateur doit préciser, parmi ces fonctions membres, lesquelles sont
autorisées à opérer sur des objets constants, en utilisant le mot const dans leur déclaration.
– Exemple :

```c++
class Point {
    int x, y;
    public:
        Point(...);
        void affiche() const;
        void deplace(...);
};
```

### Fonctions membre constantes

– Propriétés :
Spécifier que la fonction affiche est constante a deux conséquences :

1. Elle est utilisable pour un objet déclaré constant (« Point constant »). La fonction deplace,
   qui n’a pas fait l’objet d’une déclaration const ne le sera pas. Ainsi, avec :
   Point a;
   const Point c;

- Les instructions suivantes seront correctes :

```c++
a.affiche () ;
c.affiche () ;
a.deplace (...) ;

// celle-ci sera rejetée par le compilateur :
c.deplace(...); // incorrect ; c est constant, alors que deplace ne l’est pas.

// La même remarque s’appliquerait à un objet reçu en argument :
void f(const Point p) { // ou même void f(const Point & p) - voir remarque
    p.affiche(); // OK
    p.deplace(...); // incorrect
}
```

2. Les instructions figurant dans sa définition ne doivent pas modifier la valeur des
   membres de l’objet Point :

```c++
class Point {
    int x, y;
    public:
        void affiche() const {
            x++; // erreur car affiche a été déclarée const
        }
};
```

• Les membres statiques font exception à cette règle, car ils ne sont pas associés
à un objet particulier :

```c++
class Compte {
    static int n;
    public:
        void test() const{
            n++; //OK, bien que test soit déclarée constante, car n est statique
        }
};
```

– Remarques :
• On peut surdéfinir une fonction membre en se fondant sur la présence ou l’absence du
qualificatif const. Dans Point :

```c++
void affiche() const; // affiche I
void affiche(); // affiche II

//Avec ces déclarations :
Point a ;
const Point c ;

a.affiche(); //appele affiche II
c.affiche(); //appele afficehe I
```

### Membres mutables

– Une fonction membre constante ne peut pas modifier les valeurs des membres NON statiques.
– Le qualificatif mutable a cependant été introduit pour désigner des champs dont on accepte la modification, même par des fonctions membres constantes.
– Exemple :

```c++
class Truc {
    int x, y;
    mutable int n; // n est modifiable par une fonction membre constante

    void f(.....) {
        x = 5; n++;
    } // rien de nouveau ici

    void f1(.....) const {
        n++; // OK car n est déclaré mutable
        x = 5; // erreur : f1 est const et x n’est pas mutable
    }
};

```

Exemple (suite):
• Les membres publics déclarés avec le qualificatif mutable sont modifiables par
affectation :

```c++
class Truc2 {
public:
    int n;
    mutable int p;
};

const Truc2 c;
c.n = 5; // erreur : l’objet c est constant et n n’est pas mutable
c.p = 5; // OK : l’objet c est constant, mais p est mutable

```

## Objets

### Objets automatiques et statiques

– Les objets automatiques sont ceux créés par une déclaration :
• dans une fonction : Ils sont détruits à la fin de l’exécution de la fonction.
• dans un bloc : ils sont détruits lors de la sortie du bloc.
– Les objets statiques sont ceux créés par une déclaration située :
• en dehors de toute fonction ;
• dans une fonction, mais assortie du qualificatif static.

- Les objets statiques sont créés avant le début de l’exécution de la fonction main et détruits après la fin de son exécution.
  – Construction et destruction :
  • le constructeur est appelé après la création de l’objet ;
  • le destructeur est appelé avant la destruction de l’objet.

### Object dynamique

```c++
class Point {
int x, y;
public:
void initialise(int, int);
void deplace(int, int);
void affiche();
};

point *adr = new Point; //no constructor
delete adr;
```

#### Constructeur de copie (ou recopie)

- Permet d’initialiser un objet lors de son instanciation à partir d’un autre objet. Toute classe
  dispose d’un constructeur de copie par défaut généré automatiquement par le compilateur, dont le
  seul but est de recopier les champs de l’objet à recopier un à un dans les champs de l’objet à
  instancier. Toutefois, ce constructeur par défaut ne suffira pas toujours, et le programmeur devra
  parfois en fournir un explicitement. Ce sera le cas lorsque certaines données des objets auront été
  allouées dynamiquement. Une copie brutale des champs d’un objet dans un autre ne ferait que
  recopier les pointeurs, pas les données pointées. Ainsi, la modification
  int(const Point&);
- Si ce constructeur de recopie est privé, il n’est appelable que par des fonctions membres de la
  classe. (erreur de compilation).
  – Si on souhaite interdire la contruction par recopie, on peut :
  • le déclarer privé;
  • utiliser la possiblité offerte par C++ de déclarer une fonction sans en fournir de définition :
  dans ce cas toute tentative de copie (même par une fonction membre) sera rejetée ;
  • combiner les deux possibilités : effectuer une déclaration privée, sans définition ; dans ce cas,
  les tentatives de recopie par l’utilisateur resteront détectées en compilation (message explicite)
  et seules les recopies par une fonction membre se limiteront à une erreur d’édition de liens (et
  ce point ne concerne que le concepteur de la classe, pas son utilisateur !).

### Constructeur de recopie

```c++
class Vect{
int nelem; // nombre d’éléments
double* adr; // pointeur sur ces éléments
public:
Vect(int n) { // constructeur "usuel"
adr = new double[nelem = n];
cout << "+ const. usuel - adr objet : " << this
<< " - adr vecteur : " << adr << "\n";
}
Vect(const Vect& v) { // constructeur de recopie
adr = new double[nelem = v.nelem]; // création nouvel objet
int i;
for (i = 0; i<nelem; i++) adr[i] = v.adr[i];//recopie de l’ancien
cout << "+ const. recopie - adr objet : " << this << " - adr
vecteur : " << adr << "\n";
}
~Vect() { // destructeur
cout << "- Destr. objet - adr objet : "<< this << " - adr;
vecteur : " << adr << "\n";
delete adr;}
};
```

- On utilise reference car constructeur par valeur appelerait le constructeur qui causerait un recursion infini
