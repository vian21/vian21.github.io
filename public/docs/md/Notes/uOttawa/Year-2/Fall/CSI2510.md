# CSI2510

## Definition

- `structure de donnee`: un moyen de stocker et d'organiser des donnees dans un ordinateur pour qu'elles puissent être utilisées efficacement
- `algorithme`: une suite d'instructions qui prend un ensemble de donnees en entree et produit un ensemble de donnees en sortie
- `complexité`: mesure de la performance dun algorithme

# Data structures

- Simple data structures:
  - array || tableau
  - singly linked list
- `why Simple?`: parce qu'ils correspondent a comment la memoire est organisee

- complex data structures:

  - doubly linked list

- Basic ops
  - insertion || insert
  - recherche || search
  - retrait/supprimer || remove

### complexity

| Avec n elements          | Insertion | Recherche | Retrait par element | Retrait par position |
| ------------------------ | --------- | --------- | ------------------- | -------------------- |
| Tableau Simple           | O(1)      | O(n)      | O(n)                | O(1)                 |
| Tableau ordonne          | O(n)      | O(logn)   | O(n)                | O(n)                 |
| Tableau extensible       | O(n)      | O(n)      | O(n)                | O(1)                 |
| Liste chaînée            | O(1)      | O(n)      | O(n)                | O(n)                 |
| Liste doublement chaînée | O(1)      | O(n)      | O(n)                | O(n)                 |

- insert in dynamic array: O(1)- O(n+1)
- takes on average o(2) time to insert an element in a dynamic array
- N = (0->n)∑ 2^k
- N: number of operations/ affectations
- n: number of times the array is grown

```
N = 2^n
sig(0->n)(2^k) = 2^(n+1) - 1    //for all geometric sums use this
Therefore, 2^(n+1)- 1 = 2*2^n - 1
                      = 2* N -1

```

- So, it take 2N-1 operations to add N elements to a dynamic array. Divide that by N to find the average growth
- Average Insert for dynamic array -> O(2)

## Type de Donnees abstraite

- plus complexes que les structures de donnees simple
- ne correspond pas a organization de la mémoire
- des fois une abstraction du monde reel
- Independent de sa réalisation
- a des comportements et des propriétés(operations)
- definitions of how data will be stored. Does not specify how the TAD will be implemented

### Pile || stack

- properties
  - dimension || length
- Operations

  - Empile || push
  - Depile || pop

- The above are the basic stack ops, Java added more ops

# Lec

Wed 13th 2023

## TAD Pile

- implimentation en utilisant:
  - Tableau
  - Tableau extensible

## TAD File

- Implimenter en utilisant:
  - Tableau
  - tableau circulaire
  - list chaine

## Tableau Circulaire

- 2 pointeurs: D et F
- `D`: debut (pointeur au premier element du tableau)
- `F`: fin du tableau (pointeur a la prochaine place libre)
- `C`: capacite du tableau

- N(nombre d'elements) = F-D
- N (quand D est devant F) = C-D+F = F-D +C
- Qu'est c que ce passe si D == F? Le file est pleine ou vide. Il faut tester chaque fois qu'on insert ou retire qlq chose de la file. A linsertion, alors la file est pleine. Au retrait, la file est vide.

## TAD Arbre

- chaque noeud a des enfants
- Racine: noeud initiale, sans parent
- Feuille externe: Noeuds aux extremites de l'arbre
- Hauteur: distance entre la racine et la feuille la plus profonde
- Distance(A,b): nombre de branche entre ces deux Noeuds
- Niveau: entier qui distance de la racine
- Arite: le nombre maximum d'enfant.

## Arbre Binaire

- Arbre avec une arite de 2
- Nombre total de noeud = 2^(h+1) - 1
- N minimum de noeud pour h = h + 1
- log(n+1) <= h <= n - 1
- n = e + i
- e: # noeud externe
- i: # noeud interne(tout les noeuds qui ont des enfants sont interne), racine inclut s'il y d'autres noeuds dans d'arbre. Non inclut si cest le seul noeud.

## Arbre binaire Pleins(Propre)

- Abre binaire ou chaque noeud a 0 ou 2 enfants
- e = i+1
- i = (n-1)/2
- 2h+1 <=n <= 2^(h+1)-1
- (n-1)/2<= h <= log(h-1) +1

## Arbres parfait

- chaque noeud a 2 enfants
- n = 2^(h+1) - 1
- h = log(n+1) -1

## Arbre complet

- Arbre parfait jusqu'au niveau h-1 et les noeuds suivants se presentent de gauche a droite
- noeuds = 2^h

## Anlayse

ALgorithme:

## Efficacite d'un algorithme

- Critere:
  - temps d;execution
  - espace memoire occupe
  - qualite du resultat
  - simplicite d'execution

## Temps d;execution

- estimer le temps dans le cas moyen est souvent difice
- On s;interesse au temps d'execution dans le pire des cas
  - plus facile a analyse
  - decrit mieux l;efficacite
  - importance cruxiale dans certaines application. eg temps reelle

### Approche 1 - Analyse experimentale

- Excuter l;algo avec des ensembles de donnes de tailles varie
- Limitations:
  - implementations requise
  -

## Analyse Theorique

- utilise une description de haut niveau de l'algorithme
- caracterise le temps comme une fonction de la taille des donnees entree
-

* Operations primitives: operations de bas niveau qui sont independantes du langage de programmation. e,g appel et reror dune methode, operations arithmetiquem comparaison de deux nombres, affectation d;une variable
* On compte:
  1. # affectactions
  2. # de comparaison

## Ordres de grandeur - COmportement asymptotique

- Limite asymptotique superieure - O (Grand O)

### Theoreme 1

- si f(n) est O(g(n)), laors pour nimporte qulle constante K>0, f(n) est aussi O(K\*g(n))

### Theoreme 2

- Si f1(n) = O(g1(n)) et f2 = O(g2(n)) alore f1(n)+ f2(n) = O(max(g1(n), g2(n)))

- Utiliser la classe la plus simple. i.e 5n+3 est dominee par n^3 mais la meilleur formulation serait O(n)

### terminologie TODO

- O(1) - Constante
- O(n) - Lineare
- O(n^2) - Quadratic
- O(n^3) - Cubique
- O(n^k) K>0 - polynomial
- O(2^2)

### Limtes asymptotique inferieure - Omega

### Grand theta

- f(n) dommine
